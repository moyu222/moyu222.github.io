<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2025/01/23/test/"/>
    <url>/2025/01/23/test/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="date-2025-01-21tags-DataStructure-UCB"><a href="#date-2025-01-21tags-DataStructure-UCB" class="headerlink" title="date: 2025-01-21tags:  - DataStructure  - UCB"></a>date: 2025-01-21<br>tags:<br>  - DataStructure<br>  - UCB</h2><h2 id="BreadthFirstPaths"><a href="#BreadthFirstPaths" class="headerlink" title="BreadthFirstPaths"></a>BreadthFirstPaths</h2><p><strong>Tree and Graph Traversal</strong><br>[[lecture21 Tree and Graph Traversals#Tree Vs. Graph Traversals]]</p><p><strong>Shortest Paths Challenges and BFS Answer</strong><br>Initialize a queue with a starting vertex s and mark that vertex</p><ul><li>A queue is a list that has two operations: enqueue (a.k.a. addLast) and dequeue (a.k.a removeFirst)</li><li>Let’s call this queue our <em>fringe</em><br>Repeat until queue is empty</li><li>Remove vertex v from the front of the queue </li><li>For each unmarked neighbor n of v:<ul><li>Mark n</li><li>Set edgeTo[n] &#x3D; v (and&#x2F;or disTo[v] &#x3D; disTo[v] + 1)</li><li>Add n to end of queue.</li></ul></li></ul><p><strong>BreadthFirstSearch for Google Maps</strong><br>BAD!<br>edge has different distance, and discuss it in the next lecture </p><hr><h2 id="Graph-API"><a href="#Graph-API" class="headerlink" title="Graph API"></a>Graph API</h2><p>Our choices can have profound implications on :</p><ul><li>Runtime.</li><li>Memory usage</li><li>Difficulty of implementing various graph algorithms</li></ul><p><strong>Integer Vertices</strong><br><img src="/2025/01/23/test/111.png"><br><img src="/images/20250121132649.png"></p><p>Our choice of Graph API has deep implications on the implementation of DepthFirstPaths, BreadthFirstPaths, print, and other graph “clients”.</p><hr><h2 id="Graph-Representation-and-Graph-Algorithm-Runtime"><a href="#Graph-Representation-and-Graph-Algorithm-Runtime" class="headerlink" title="Graph Representation and Graph Algorithm Runtime"></a>Graph Representation and Graph Algorithm Runtime</h2><p><strong>Adjacency Matrix</strong><br><img src="/images/222.png" alt="test"></p><p><strong>Edge Sets : Collection of all edges</strong></p><ul><li>{(0, 1), (0, 2), (1, 2)}</li></ul><p><strong>Adjacency List</strong><br>![[Pasted image 20250121132957.png | 500]]<br>这个时间复杂度需要注意一下</p><p><strong>Runtime</strong><br>![[Pasted image 20250121133056.png | 500]]</p><p><strong>Bare-Bones Undirected Graph Implementation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> V;  <span class="hljs-keyword">private</span> List&lt;Integer&gt;[] adj;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> &#123;<br>         <span class="hljs-built_in">this</span>.V = V;<br>         adj = (List&lt;Integer&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[V];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>             adj[v] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>         &#125;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> &#123;<br>         adj[v].add(w);   adj[w].add(v);<br>&#125;<br><br><span class="hljs-keyword">public</span> Iterable&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-keyword">return</span> adj[v];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Graph-Traversal-implementations-and-Runtime"><a href="#Graph-Traversal-implementations-and-Runtime" class="headerlink" title="Graph Traversal implementations and Runtime"></a>Graph Traversal implementations and Runtime</h2><p><strong>Idea to implement</strong><br><img src="/2025/01/23/test/Pasted%25image%20250121133518.png" alt="Pasted%image%20250121133518"></p><p><strong>DepthFirstPaths, Recursive Implementation</strong><br><img src="/source/images/Pasted%25image%20250121133646.png"><br>![[Pasted image 20250121133700.png | 500]]</p><p><strong>O(V + E)</strong></p><ul><li>Each vertex is visited at most once (O(V)).</li><li>Each edge is considered at most twice (O(E)).  <code>marked[w]</code></li><li>sum of <ul><li>Number of dfs calls</li><li>marked[w] checks or create an all false array</li></ul></li></ul><p><strong>BreadthFirstPaths Implementation</strong><br>![[Pasted image 20250121134101.png | 500]]</p><p><strong>Graph Problems</strong><br>![[Pasted image 20250121134206.png | 500]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/22/hello-world/"/>
    <url>/2025/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_22</title>
    <link href="/2025/01/21/22/"/>
    <url>/2025/01/21/22/</url>
    
    <content type="html"><![CDATA[<h2 id="BreadthFirstPaths"><a href="#BreadthFirstPaths" class="headerlink" title="BreadthFirstPaths"></a>BreadthFirstPaths</h2><p><strong>Tree and Graph Traversal</strong><br>[[lecture21 Tree and Graph Traversals#Tree Vs. Graph Traversals]]</p><p><strong>Shortest Paths Challenges and BFS Answer</strong><br>Initialize a queue with a starting vertex s and mark that vertex</p><ul><li>A queue is a list that has two operations: enqueue (a.k.a. addLast) and dequeue (a.k.a removeFirst)</li><li>Let’s call this queue our <em>fringe</em><br>Repeat until queue is empty</li><li>Remove vertex v from the front of the queue </li><li>For each unmarked neighbor n of v:<ul><li>Mark n</li><li>Set edgeTo[n] &#x3D; v (and&#x2F;or disTo[v] &#x3D; disTo[v] + 1)</li><li>Add n to end of queue.</li></ul></li></ul><p><strong>BreadthFirstSearch for Google Maps</strong><br>BAD!<br>edge has different distance, and discuss it in the next lecture </p><hr><h2 id="Graph-API"><a href="#Graph-API" class="headerlink" title="Graph API"></a>Graph API</h2><p>Our choices can have profound implications on :</p><ul><li>Runtime.</li><li>Memory usage</li><li>Difficulty of implementing various graph algorithms</li></ul><p><strong>Integer Vertices</strong><br>![[Pasted image 20250121132630.png | 500]]<br>![[Pasted image 20250121132649.png | 500]]</p><p>Our choice of Graph API has deep implications on the implementation of DepthFirstPaths, BreadthFirstPaths, print, and other graph “clients”.</p><hr><h2 id="Graph-Representation-and-Graph-Algorithm-Runtime"><a href="#Graph-Representation-and-Graph-Algorithm-Runtime" class="headerlink" title="Graph Representation and Graph Algorithm Runtime"></a>Graph Representation and Graph Algorithm Runtime</h2><p><strong>Adjacency Matrix</strong><br>![[Pasted image 20250121132839.png | 500]]</p><p><strong>Edge Sets : Collection of all edges</strong></p><ul><li>{(0, 1), (0, 2), (1, 2)}</li></ul><p><strong>Adjacency List</strong><br>![[Pasted image 20250121132957.png | 500]]<br>这个时间复杂度需要注意一下</p><p><strong>Runtime</strong><br>![[Pasted image 20250121133056.png | 500]]</p><p><strong>Bare-Bones Undirected Graph Implementation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> V;  <span class="hljs-keyword">private</span> List&lt;Integer&gt;[] adj;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> &#123;<br>         <span class="hljs-built_in">this</span>.V = V;<br>         adj = (List&lt;Integer&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[V];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>             adj[v] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>         &#125;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> &#123;<br>         adj[v].add(w);   adj[w].add(v);<br>&#125;<br><br><span class="hljs-keyword">public</span> Iterable&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-keyword">return</span> adj[v];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Graph-Traversal-implementations-and-Runtime"><a href="#Graph-Traversal-implementations-and-Runtime" class="headerlink" title="Graph Traversal implementations and Runtime"></a>Graph Traversal implementations and Runtime</h2><p><strong>Idea to implement</strong><br>![[Pasted image 20250121133518.png | 500]]</p><p><strong>DepthFirstPaths, Recursive Implementation</strong><br>![[Pasted image 20250121133646.png | 500]]<br>![[Pasted image 20250121133700.png | 500]]</p><p><strong>O(V + E)</strong></p><ul><li>Each vertex is visited at most once (O(V)).</li><li>Each edge is considered at most twice (O(E)).  <code>marked[w]</code></li><li>sum of <ul><li>Number of dfs calls</li><li>marked[w] checks or create an all false array</li></ul></li></ul><p><strong>BreadthFirstPaths Implementation</strong><br>![[Pasted image 20250121134101.png | 500]]</p><p><strong>Graph Problems</strong><br>![[Pasted image 20250121134206.png | 500]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_21</title>
    <link href="/2025/01/20/21/"/>
    <url>/2025/01/20/21/</url>
    
    <content type="html"><![CDATA[<h2 id="Trees-and-Traversals"><a href="#Trees-and-Traversals" class="headerlink" title="Trees and Traversals"></a>Trees and Traversals</h2><p><strong>(Rooted) Tree Definition</strong><br>[[lecture16 ADTs, Sets, Maps, BSTs]]</p><ul><li>A set of nodes</li><li>A set of edges that connect those nodes <ul><li>there is exactly one path between any two nodes</li></ul></li><li>A rooted tree is a tree where we’ve chosen one node as the ‘root’</li></ul><p><strong>Trees</strong><br>We’ve seen tree as nodes in a specific data structure implementation</p><ul><li>[[lecture16 ADTs, Sets, Maps, BSTs]]</li><li>[[lecture20 Heaps and PQs]]</li><li>[[lecture14 Disjoint Sets 不相交的集]]</li><li>[[lecture17 B-Trees (2-3, 2-3-4 Trees)]]</li><li>[[lecture18 Red Black Trees]]</li></ul><p>Trees are a more general concept and have many usage and 引出Traversals</p><p><strong>Preorder, Inorder, Postorder</strong><br>略<br>![[Pasted image 20250120202243.png | 500]]</p><p><strong>What Good are all these Traversals (example)</strong><br>![[Pasted image 20250120202322.png | 500]]<br>![[Pasted image 20250120202402.png | 500]]</p><hr><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p><strong>Definition and type</strong></p><ul><li>No edges that connect a vertex to itself, i.e. no “loops”.</li><li>No two edges that connect the same vertices, i.e. no “parallel edges”<br>![[Pasted image 20250120202514.png | 500]]</li></ul><p><strong>Terminology</strong><br>![[Pasted image 20250120202549.png | 500]]</p><hr><h2 id="Graph-Problems"><a href="#Graph-Problems" class="headerlink" title="Graph Problems"></a>Graph Problems</h2><p><strong>Some well known graph problems and their common names:</strong></p><ul><li>s-t Path. Is there a path between vertices s and t?</li><li>Connectivity. Is the graph connected, i.e. is there a path between all vertices?</li><li>Biconnectivity. Is there a vertex whose removal disconnects the graph?</li><li>Shortest s-t Path. What is the shortest path between vertices s and t?</li><li>Cycle Detection. Does the graph contain any cycles</li><li>Euler Tour. Is there a cycle that uses every edge exactly once?</li><li>Hamilton Tour. Is there a cycle that uses every vertex exactly once?</li><li>Planarity. Can you draw the graph on paper with no crossing edges?</li><li>Isomorphism. Are two graphs isomorphic (the same graph in disguise)?<br>Often can’t tell how difficult a graph problem is without very deep consideration.</li></ul><p><strong>Graph Problem Difficulty</strong></p><ul><li>Euler Tour. Is there a cycle that uses every edge exactly once?</li><li>Hamilton Tour. Is there a cycle that uses every vertex exactly once?</li></ul><p>An efficient Euler tour algorithm O(# edges) was found as early as 1873<br>Despite decades of intense study, no efficient algorithm for a Hamilton tour exists. Best algorithms are exponential time.</p><hr><h2 id="Depth-First-Traversal"><a href="#Depth-First-Traversal" class="headerlink" title="Depth-First Traversal"></a>Depth-First Traversal</h2><p>![[Pasted image 20250120202951.png | 500]]<br>![[Pasted image 20250120203019.png | 500]]</p><hr><h2 id="Tree-Vs-Graph-Traversals"><a href="#Tree-Vs-Graph-Traversals" class="headerlink" title="Tree Vs. Graph Traversals"></a>Tree Vs. Graph Traversals</h2><p>![[Pasted image 20250120203250.png | 500]]<br>![[Pasted image 20250120203121.png | 500]]</p><hr><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>&#x3D;&#x3D;我懒了，随便截两张图，上学期学校基本讲过&#x3D;&#x3D;</p><p>![[Pasted image 20250120203142.png | 500]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_20</title>
    <link href="/2025/01/19/20/"/>
    <url>/2025/01/19/20/</url>
    
    <content type="html"><![CDATA[<h2 id="Priority-Queues-启发问题"><a href="#Priority-Queues-启发问题" class="headerlink" title="Priority Queues 启发问题"></a>Priority Queues 启发问题</h2><p>首先定义一下PQ接口</p><p>![[Pasted image 20250119183510.png]]</p><p>我们引出一个问题，现在要连续记录一天之内所有的语言数据，通过比较最后分析最不友好的前m个text，一个naive方法是储存所有的text，最后进行比较再得出结论，但是显然会占用大量的memory。我们引出一个更好的方法，使用一个只能储存m个text的袋子，每次增加都要首先removeSmallest，使用上文的接口</p><p>![[Pasted image 20250119183933.png]]</p><p>How Would We Implement a MinPQ? </p><ul><li>Ordered Array </li><li>Bushy BST: 有重复key的问题, Handling duplicate priorities is awkward.</li><li>HashTable: 找最小值需要$\theta(N)$</li></ul><p>我们引出Heap </p><hr><h2 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h2><p>Binary min-heap: Binary tree that is complete and obeys min-heap property.</p><ul><li>Min-heap: Even node is less than or equal to both of its children.</li><li>Complete: Missing items only at the bottom level (if any), all nodes are as far left as possible.</li></ul><p>Given a heap, how do we implement PQ operations?</p><ul><li>getSmallest( ) - return the item in the root node.</li><li>add(x) - place the new employee in the last position, and promote as high as possible.</li><li>removeSmallest( ) - assassinate 刺杀 the president (of the company), promote the rightmost person in the company to president. Then demote repeatedly, always taking the ‘better’ successor</li></ul><hr><h2 id="Tree-Representations"><a href="#Tree-Representations" class="headerlink" title="Tree Representations"></a>Tree Representations</h2><p>![[Pasted image 20250119192009.png]]</p><p>这部分就简单写了，tree装的表示方法列举了3种表示方法，之后又通过以前讲的disjoint set引出使用Array表示tree。[[lecture14 Disjoint Sets 不相交的集]]</p><p>![[Pasted image 20250119192325.png]]</p><p>![[Pasted image 20250119194040.png]]</p><p>使用一个0，防止k-1时得到负数，简化code</p><p>![[Pasted image 20250119194126.png]]</p><hr><h2 id="Data-Structures-Summary"><a href="#Data-Structures-Summary" class="headerlink" title="Data Structures Summary"></a>Data Structures Summary</h2><p>![[Pasted image 20250119194216.png]]</p><p>![[Pasted image 20250119194507.png]]<br>![[Pasted image 20250119194519.png]]<br>![[Pasted image 20250119194535.png]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_19</title>
    <link href="/2025/01/14/19/"/>
    <url>/2025/01/14/19/</url>
    
    <content type="html"><![CDATA[<h2 id="Data-Indexed-Array"><a href="#Data-Indexed-Array" class="headerlink" title="Data Indexed Array"></a>Data Indexed Array</h2><p>![[Pasted image 20250114104355.png]]</p><h3 id="Limits-of-Search-Tree-Based-Sets"><a href="#Limits-of-Search-Tree-Based-Sets" class="headerlink" title="Limits of Search Tree Based Sets"></a>Limits of Search Tree Based Sets</h3><p>Our search tree based sets require items to be comparable.</p><ul><li>&#x3D;&#x3D;Need to be able to ask “is X &lt; Y?” Not true of all types&#x3D;&#x3D;.</li><li>Could we somehow avoid the need for objects to be comparable?</li></ul><p>Our search tree sets have excellent performance, but could maybe be better?</p><ul><li>Θ(log N) is amazing. 1 billion items is still only height ~30.</li><li>&#x3D;&#x3D;Could we somehow do better than Θ(log N)&#x3D;&#x3D;?</li></ul><p>![[Pasted image 20250114105509.png]]</p><ul><li>我们使用一个布尔值创建一个数据索引，避免了比较但是严重浪费内存，我们需要一些方法to generalize beyond inegers</li></ul><hr><h2 id="DataIndexedEnglishWordSet"><a href="#DataIndexedEnglishWordSet" class="headerlink" title="DataIndexedEnglishWordSet"></a>DataIndexedEnglishWordSet</h2><p>类似进制转化，我们转化所有English Word<br>![[Pasted image 20250114110414.png]]</p><ul><li>collision碰撞不会发生，因为不同单词得到不同的转换值<br>![[Pasted image 20250114110644.png]]<br>![[Pasted image 20250114110700.png]]</li></ul><hr><h2 id="DataIndexedStringSet"><a href="#DataIndexedStringSet" class="headerlink" title="DataIndexedStringSet"></a>DataIndexedStringSet</h2><p>Using only lowercase English characters is too restrictive.</p><ul><li>What if we want to store strings like “2pac” or “eGg!”?</li><li>To understand what value we need to use for our base, let’s discuss briefly discuss the ASCII standard.<br>![[Pasted image 20250114111413.png]]<br>![[Pasted image 20250114111456.png]]<br>![[Pasted image 20250114111525.png]]<br>我们可以看出单纯的data index 有些冗长，这可能成为问题</li></ul><hr><h2 id="Integer-Overflow-and-Hash-Codes"><a href="#Integer-Overflow-and-Hash-Codes" class="headerlink" title="Integer Overflow and Hash Codes"></a>Integer Overflow and Hash Codes</h2><p>java integer有最大值，这就导致了collisions<br>![[Pasted image 20250114112054.png]]<br>The official term for the number we’re computing is &#x3D;&#x3D;”hash code”&#x3D;&#x3D;</p><ul><li>a hash code “<em>projects a value from a set with many (or even an infinite number of) members to a value from a set with a fixed number of (fewer) members</em>“<br>Two challenges:</li><li>resolve hashCode collisions</li><li>computing a hashCode</li></ul><hr><h2 id="Hash-Tables-Handling-Collisions"><a href="#Hash-Tables-Handling-Collisions" class="headerlink" title="Hash Tables: Handling Collisions"></a>Hash Tables: Handling Collisions</h2><ul><li>&#x3D;&#x3D;use “bucket” instead of storing true in position h&#x3D;&#x3D;</li><li>we can use LinkedList, ArrayList, ArraySet… ot implement a bucket</li><li>if bucket h is empty, we create a new list to stores</li><li>if bucket h is already a list, we should check if the hashcode has already in the bucket<br>![[Pasted image 20250114113308.png]]<br>![[Pasted image 20250114113319.png]]</li><li>because we should look up if it has existed </li><li>if we use 10 buckets on the right, &#x3D;&#x3D;we compute hashCode % 10&#x3D;&#x3D;<br>![[Pasted image 20250114113438.png]]</li></ul><hr><h2 id="Hash-Table-Performance"><a href="#Hash-Table-Performance" class="headerlink" title="Hash Table Performance"></a>Hash Table Performance</h2><p>![[Pasted image 20250114114450.png]]</p><ul><li>我们需要改进，避免$\theta(N)$, and achieve $\theta(1)$</li><li>跟ArrayList一样我们引入&#x3D;&#x3D;resize &#x3D;&#x3D;的思想</li></ul><p>![[Pasted image 20250114114636.png]]<br>![[Pasted image 20250114114655.png]]<br>Assuming items are &#x3D;&#x3D;evenly distributed 均匀分布&#x3D;&#x3D;(as above), lists will be approximtely N&#x2F;M items long, resulting in $\theta(N&#x2F;M)$ runtime </p><ul><li>our doubling strategy ensures that &#x3D;&#x3D;N&#x2F;M &#x3D; O(1)&#x3D;&#x3D;</li><li>Thus, worst case runtime for all operations is &#x3D;&#x3D;Θ(N&#x2F;M) &#x3D; Θ(1&#x3D;&#x3D;).</li><li>though resize takes $\theta(N)$ time, and add operation takes $\theta(N)$ time, similar to our ALists, we still have average runtime $\theta(1)$</li></ul><h3 id="应该是忽略了resize的-theta-N-time，反正总结一句话就是resize这种方法，在假设均匀分布的情况下都是-theta-1"><a href="#应该是忽略了resize的-theta-N-time，反正总结一句话就是resize这种方法，在假设均匀分布的情况下都是-theta-1" class="headerlink" title="应该是忽略了resize的$\theta(N)$ time，反正总结一句话就是resize这种方法，在假设均匀分布的情况下都是$\theta(1)$"></a>应该是忽略了resize的$\theta(N)$ time，反正总结一句话就是resize这种方法，在假设均匀分布的情况下都是$\theta(1)$</h3><p>![[Pasted image 20250114115019.png]]<br>![[Pasted image 20250114115311.png]]</p><hr><h2 id="Hash-Tables-in-Java"><a href="#Hash-Tables-in-Java" class="headerlink" title="Hash Tables in Java"></a>Hash Tables in Java</h2><ol><li>Hash tables are the most popular implementation for sets and maps.<ul><li>Great performance in practice </li><li>Don’t require items to be comparable</li><li>Implementations often relatively simple</li><li>Python dictionsries are just hash tables in disguise  Python字典只是伪装的哈希表</li></ul></li><li>In java, implemented as <code>java.util.HashMap </code>and <code>java.util.HashSet</code><ul><li>all objects in java implement a <code>.hashCode(</code>) method<br> ![[Pasted image 20250114130617.png]]</li></ul></li><li>Using negative hash codes in Java <ul><li>-1 % 4 &#x3D; -1, so we can use<code> Math.floorMod</code> instead<br> ![[Pasted image 20250114130754.png]]</li></ul></li><li>Hash Tables in Java <ul><li>we use <code>.equals()</code> to decide if there is a same item in the buckets</li><li>hash code -&gt; valid index<br> ![[Pasted image 20250114131101.png]]</li></ul></li><li>Two important Warining When Using HashMaps&#x2F;HashSets<ul><li>不能储存可变的的对象，因为变化会导致hashCode变化</li><li>在没有重写<code>hashCode</code>时，不能重写<code>equal</code>方法，因为需要使用equal判断item 是否存在在bucket</li></ul></li></ol><hr><h2 id="Good-HashCode"><a href="#Good-HashCode" class="headerlink" title="Good HashCode"></a>Good HashCode</h2><ol><li>我们想要得到的hashcode可以尽可能均匀分布在buckets中，我们要让hash function 尽可能随机</li><li>现实例子，使用base 31 表示string，原因在于大于31后因为overflow所有最后32个字母相同的string都有相同的hash code<br> ![[Pasted image 20250114133133.png]]<br> ![[Pasted image 20250114133214.png]]</li><li>一个典型的hash code base是一个小的质数。质数避免overflow并且降低造成hashCode和buckets数量不良关系的几率；small保证容易计算</li><li>berrer “randomness”<ol><li>![[Pasted image 20250114134503.png]]</li><li>![[Pasted image 20250114134511.png]]</li></ol></li></ol><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>![[Pasted image 20250114134536.png | 500]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_15</title>
    <link href="/2025/01/13/15/"/>
    <url>/2025/01/13/15/</url>
    
    <content type="html"><![CDATA[<p>本节简单分析一些算法的时间复杂度</p><ul><li>for -for.   n</li><li>recursion.   2^n</li><li>binary search  logn</li><li>selection sort n^2</li><li>merge sort.   nlogn<br>不做详细笔记了</li></ul><p><strong>Runtime Analysis.</strong><br>Understanding the runtime of code involves deep thought. It amounts to asking: “How long does it take to do stuff?”, where stuff can be any conceivable computational process whatsoever. It simply cannot be done mechanically, at least for non-trivial problems. As an example, a pair of nested for loops does NOT mean Θ(N^2) runtime as we saw in lecture.</p><p><strong>Cost Model.</strong> <br>As an anchor for your thinking, recall the idea of a “cost model” from last lecture. Pick an operation and count them. You want the one whose count has the highest order of growth as a function of the input size.</p><p><strong>Important Sums.</strong> This is not a math class so we’ll be a bit sloppy, but the two key sums that you should know are that:</p><ul><li>1+2+3+…+N∈Θ(N^2)</li><li>1+2+4+8+…+N∈Θ(N)</li></ul><p><strong>Practice.</strong> <br>The only way to learn this is through plenty of practice. Make sure to work through the problems in lecture and below when you have some time.</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_16</title>
    <link href="/2025/01/13/16/"/>
    <url>/2025/01/13/16/</url>
    
    <content type="html"><![CDATA[<h2 id="ADT-Abstract-Data-Types"><a href="#ADT-Abstract-Data-Types" class="headerlink" title="ADT Abstract Data Types"></a>ADT Abstract Data Types</h2><p><img src="/2025/01/13/16/Pasted%20image%2020250113105822.png"></p><ul><li>我们定义的deque是ADT，而ArrayDeque和LinkedListDeque是deque的实现</li><li>后文学的所有抽象的数据结构包括stack等，使用他们的功能定义的，具体实现我们不关心的都属于ADT<br> <img src="/2025/01/13/16/Pasted%20image%2020250113110452.png"></li></ul><h3 id="Abstract-Data-Types-in-Java"><a href="#Abstract-Data-Types-in-Java" class="headerlink" title="Abstract Data Types in Java"></a>Abstract Data Types in Java</h3><ul><li>许多java.util library 中的重要接口都继承了Collection接口</li><li>这些接口都是ADT，有不同的方法实现，我们关注&#x3D;&#x3D;TreeSet and TreeMap&#x3D;&#x3D;</li><li>下文讲了map的一个例子 ，map有点像字典，可以看作有联系的array. associative arrays<br><img src="/2025/01/13/16/Pasted%20image%2020250113111439.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113111502.png"></li></ul><h2 id="Binary-Search-Trees-Definitions"><a href="#Binary-Search-Trees-Definitions" class="headerlink" title="Binary Search Trees Definitions"></a>Binary Search Trees Definitions</h2><ul><li>Tree: <ul><li>a set of node </li><li>a set of edges that connect those nodes </li><li>两个节点之间只能有一条path(不能有cycle)</li></ul></li><li>Rooted Trees and Rooted Binary Trees <ul><li>除了root每个节点都要有一个Parent</li><li>没有child的叫做leaf</li></ul></li><li>BST: a rooted Binary Tree with BST property <ul><li>Every key in the left subtree is less than X’s key.</li><li>Every key in the right subtree is greater than X’s key.  </li><li> complete, transitive, and antisymmetric.<br><img src="/2025/01/13/16/Pasted%20image%2020250113112932.png"></li></ul></li></ul><h2 id="BST-Operation"><a href="#BST-Operation" class="headerlink" title="BST Operation"></a>BST Operation</h2><h3 id="reasearch"><a href="#reasearch" class="headerlink" title="reasearch"></a>reasearch</h3><p><img src="/2025/01/13/16/Pasted%20image%2020250113113749.png"></p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><img src="/2025/01/13/16/Pasted%20image%2020250113113829.png"></p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>3 Cases:</p><ul><li>Deletion key has no children.</li><li>Deletion key has one child.</li><li>Deletion key has two children.<br><img src="/2025/01/13/16/Pasted%20image%2020250113114652.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113114706.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113114721.png"></li><li>第三种情况最复杂，我们找到root的predecessor or successor </li><li>delete其中一个然后换到root<br><img src="/2025/01/13/16/Pasted%20image%2020250113114851.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113114859.png"></li></ul><h2 id="Sets-vs-Maps-and-Summary"><a href="#Sets-vs-Maps-and-Summary" class="headerlink" title="Sets vs. Maps and Summary"></a>Sets vs. Maps and Summary</h2><p><img src="/2025/01/13/16/Pasted%20image%2020250113115251.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113115259.png"><br><img src="/2025/01/13/16/Pasted%20image%2020250113115331.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_17</title>
    <link href="/2025/01/13/17/"/>
    <url>/2025/01/13/17/</url>
    
    <content type="html"><![CDATA[<h2 id="Height-Depth-and-Performance"><a href="#Height-Depth-and-Performance" class="headerlink" title="Height, Depth, and Performance"></a>Height, Depth, and Performance</h2><p><img src="/2025/01/13/17/Pasted%20image%2020250113190526.png"><br>本节主要讲的就是，我们用随机insert模拟现实使用时BST的形状以估计他的性能</p><ul><li>结果表示随机insert, deletion都会生成近似密集的tree，the worst case time of contaion opertaion is $\theta(logN)$</li><li>然而我们不可能在现实中总是随机insert, 因为我们可能不会提前有所有数据，例如随时间进行产生的数据</li></ul><h2 id="B-trees-2-3-trees-2-3-4-trees"><a href="#B-trees-2-3-trees-2-3-4-trees" class="headerlink" title="B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees"></a>B-trees &#x2F; 2-3 trees &#x2F; 2-3-4 trees</h2><h3 id="B-tree-Basic-Insertion"><a href="#B-tree-Basic-Insertion" class="headerlink" title="B-tree Basic Insertion"></a>B-tree Basic Insertion</h3><ul><li>&#x3D;&#x3D;已经有了一个balanced的BST&#x3D;&#x3D;，为了最大程度避免tree变细长，当我们要添加一些node时&#x3D;&#x3D;我们直接不添加新leaf在底部。&#x3D;&#x3D;</li><li>我们将新node添加到leaf nodes中 “overstuffing”</li><li>为了避免在单个node中添加过多，使得tree退化成list，我们限定每个node位置的item数量，&#x3D;&#x3D;使用move up调节&#x3D;&#x3D; “leaf nodes can be too juicy”</li><li>分割节点例如，&#x3D;&#x3D;保证ST的核心思想虽然已经不再是BST，即通过比较明确访问的下游node，嗯自己想的&#x3D;&#x3D;<br><img src="/2025/01/13/17/Pasted%20image%2020250113192749.png"><br><img src="/2025/01/13/17/Pasted%20image%2020250113192822.png"><br><img src="/2025/01/13/17/Pasted%20image%2020250113192853.png"><br><img src="/2025/01/13/17/Pasted%20image%2020250113192938.png"></li></ul><h3 id="What-happens-if-the-rooted-is-too-full"><a href="#What-happens-if-the-rooted-is-too-full" class="headerlink" title="What happens if the rooted is too full?"></a>What happens if the rooted is too full?</h3><p><img src="/2025/01/13/17/Pasted%20image%2020250113193629.png"></p><h3 id="Splitting-Non-Leaf-nodes-Terminology"><a href="#Splitting-Non-Leaf-nodes-Terminology" class="headerlink" title="Splitting Non Leaf nodes, Terminology"></a>Splitting Non Leaf nodes, Terminology</h3><ol><li>Observation: Splitting-trees have perfect balance<ul><li>If we split the root, every node gets pushed down by exactly one level.</li><li>If we split a leaf node or internal node, the height doesn’t change </li><li>So all operation hava guaranteed $O(logN)$</li></ul></li><li>&#x3D;&#x3D;Rename Splitting tree as B-tree 也叫2-3tree等等&#x3D;&#x3D;</li><li><img src="/2025/01/13/17/Pasted%20image%2020250113194055.png"></li></ol><h2 id="B-tree-Bushiness-Invariant-繁茂"><a href="#B-tree-Bushiness-Invariant-繁茂" class="headerlink" title="B-tree Bushiness Invariant 繁茂"></a>B-tree Bushiness Invariant 繁茂</h2><p><img src="/2025/01/13/17/Pasted%20image%2020250113195313.png"></p><ul><li>因为B-Tree从下向上生成，所以所有leaf到root的距离相同</li><li>不是leaf的有k个item的node节点，一定有k+1个children</li><li>&#x3D;&#x3D;这些不变形保证了b-tree 的bushy属性&#x3D;&#x3D;</li></ul><h2 id="Runtime-Analysis-Summary"><a href="#Runtime-Analysis-Summary" class="headerlink" title="Runtime Analysis, Summary"></a>Runtime Analysis, Summary</h2><p><img src="/2025/01/13/17/Pasted%20image%2020250113200015.png"></p><ul><li>height: $\theta(logN)$</li><li>contain and add: O(HL) - O(logN)</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2025/01/13/17/Pasted%20image%2020250113200231.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_18</title>
    <link href="/2025/01/13/18/"/>
    <url>/2025/01/13/18/</url>
    
    <content type="html"><![CDATA[<h2 id="Tree-Rotation"><a href="#Tree-Rotation" class="headerlink" title="Tree Rotation"></a>Tree Rotation</h2><p>2-3 tree 又一些问题包括：</p><ul><li>&#x3D;&#x3D;维护不同的节点类型&#x3D;&#x3D;</li><li>2节点和3节点之间的&#x3D;&#x3D;节点转换&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;walk up &#x3D;&#x3D;the tree to split the nodes<br><img src="/2025/01/13/18/Pasted%20image%2020250113203803.png"><br>我们要改进结构，使用旋转&#x3D;&#x3D;，left and right rotation&#x3D;&#x3D;，降低height<br><img src="/2025/01/13/18/Pasted%20image%2020250113203919.png"></li></ul><h2 id="Balancing-with-Rotation"><a href="#Balancing-with-Rotation" class="headerlink" title="Balancing with Rotation"></a>Balancing with Rotation</h2><p>comp2013学过了，简略截图<br><img src="/2025/01/13/18/Pasted%20image%2020250113204549.png"></p><h2 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a>Red-Black Trees</h2><p>我们已知两种类型的search trees:</p><ul><li>Binary search tree: 我们可以使用rotation，但是目前还没有定义算法</li><li>2-3 trees: 通过结构平衡，即不需要旋转<br>Our Goals: &#x3D;&#x3D;建立一个BST，他的结构等同于2-3tree&#x3D;&#x3D;</li><li>Since 2-3 trees are balanced, so will our special BSTs</li></ul><h3 id="Representing-a-2-3-Tree-as-a-BST"><a href="#Representing-a-2-3-Tree-as-a-BST" class="headerlink" title="Representing a 2-3 Tree as a BST"></a>Representing a 2-3 Tree as a BST</h3><ul><li>2-nodes is trival, how about 3-nodes?</li><li>可以创建一个虚拟glue node，但是浪费link, code will be ugly</li><li>&#x3D;&#x3D;Create “glue” links with the smaller item Off to the left&#x3D;&#x3D;<br><img src="/2025/01/13/18/Pasted%20image%2020250113210159.png"><br><img src="/2025/01/13/18/Pasted%20image%2020250113210209.png"></li><li>commonly used in practice and 我们将胶水链接标记为“红色”</li><li>&#x3D;&#x3D;Left-Leaning 左倾的 LLRB &#x3D;&#x3D;<br><img src="/2025/01/13/18/Pasted%20image%2020250113210345.png"><br><img src="/2025/01/13/18/Pasted%20image%2020250113210400.png"></li></ul><h2 id="Red-Black-Tree-Properties"><a href="#Red-Black-Tree-Properties" class="headerlink" title="Red Black Tree Properties"></a>Red Black Tree Properties</h2><h3 id="Problem-1-which-LLRBs-is-true"><a href="#Problem-1-which-LLRBs-is-true" class="headerlink" title="Problem 1 which LLRBs is true"></a>Problem 1 which LLRBs is true</h3><p><img src="/2025/01/13/18/Pasted%20image%2020250114032418.png"></p><ul><li>对应的2-3tree应该是balanced的，&#x3D;&#x3D;而且不能有4nodes&#x3D;&#x3D;</li></ul><h3 id="Problem-2-The-height-of-the-LLRB"><a href="#Problem-2-The-height-of-the-LLRB" class="headerlink" title="Problem 2 The height of the LLRB"></a>Problem 2 The height of the LLRB</h3><p><img src="/2025/01/13/18/Pasted%20image%2020250114032601.png"></p><ul><li>因此Red black tree的height也是$log(N)$</li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="/2025/01/13/18/Pasted%20image%2020250114032805.png"></p><ul><li>no two red links </li><li>same number of black links<br>我们如何construct LLRBs，基本思想是在像平常一样嵌入BST的同时使用rotations 去保证1-1mapping</li></ul><h2 id="Maintaining-1-1-Correspondence-Trough-Rotations"><a href="#Maintaining-1-1-Correspondence-Trough-Rotations" class="headerlink" title="Maintaining 1-1 Correspondence Trough Rotations"></a>Maintaining 1-1 Correspondence Trough Rotations</h2><p><img src="/2025/01/13/18/Pasted%20image%2020250114034547.png"><br>&#x3D;&#x3D;我们默认每次insert value都使用red link&#x3D;&#x3D;<br><img src="/2025/01/13/18/Pasted%20image%2020250114034642.png"><br>我们让每次insert都是red link 会导致出现&#x3D;&#x3D;两个red link的情况&#x3D;&#x3D;，我们暂时容许这种情况的出现，有两种情况<br><img src="/2025/01/13/18/Pasted%20image%2020250114034814.png"></p><p>第一种double left insert</p><p><img src="/2025/01/13/18/Pasted%20image%2020250114034915.png"><br><img src="/2025/01/13/18/Pasted%20image%2020250114035143.png"></p><p>第二种child 两个red<br><img src="/2025/01/13/18/Pasted%20image%2020250114035033.png"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2025/01/13/18/Pasted%20image%2020250114035112.png"></p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><p><img src="/2025/01/13/18/Pasted%20image%2020250114040007.png"><br><img src="/2025/01/13/18/Pasted%20image%2020250114040019.png"></p><h2 id="LLRB-Runtime-and-implementation"><a href="#LLRB-Runtime-and-implementation" class="headerlink" title="LLRB Runtime and implementation"></a>LLRB Runtime and implementation</h2><p><img src="/2025/01/13/18/Pasted%20image%2020250114040752.png"><br><img src="/2025/01/13/18/Pasted%20image%2020250114040808.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_14</title>
    <link href="/2025/01/11/14/"/>
    <url>/2025/01/11/14/</url>
    
    <content type="html"><![CDATA[<h2 id="Intro-to-Disjoint-Sets"><a href="#Intro-to-Disjoint-Sets" class="headerlink" title="Intro to Disjoint Sets"></a>Intro to Disjoint Sets</h2><ul><li>Today: Deriving the “Disjoint Sets” data structure for solving the “&#x3D;&#x3D;Dynamic Connectivity”&#x3D;&#x3D; problem</li><li>Disjoint Sets 数据结构有两个操作：<ul><li>connect(x, y): Connects x and y.</li><li>isConnected(x, y): Returns true if x and y are connected, Connections can &#x3D;&#x3D;be transitive&#x3D;&#x3D;, i.e. they doun’t need to be direct.<br><img src="/2025/01/11/14/Pasted%20image%2020250111105319.png"></li></ul></li><li>dynamic: 连接情况是动态变化的</li><li>Goal: 设计一个高效的DisjointSets 接口实现</li></ul><h3 id="Better-Approach-Connected-components"><a href="#Better-Approach-Connected-components" class="headerlink" title="Better Approach: Connected components"></a>Better Approach: Connected components</h3><ul><li>初始的方法是记录所有连接</li><li>我们可以使用集合的概念，将connected的接待您放在一个connected component 中<br> <img src="/2025/01/11/14/Pasted%20image%2020250111105953.png"></li></ul><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><ol><li>use a list of DS(disjoint set) - bad and slow </li><li>Just use a List of Integers (Quick Find)<br><img src="/2025/01/11/14/Pasted%20image%2020250111110515.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111110532.png"></li></ol><ul><li>isConnected is very good and $\theta(1)$ ,but connet method need us to modify many numbers in the list and it is relatively slow $\theta(N)$</li></ul><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><ul><li>Next approach (QuickUnion): We will still represent everything as connected components, and we will still represent connected components as a list of integers. However, &#x3D;&#x3D;values will be chosen so that connect is fast&#x3D;&#x3D;.</li><li>接着上文QF进行延伸，我们改变选择的值，使得结合两个集后变成他们的并集只改变一个值</li><li>idea: 我们使用他的父类而不是id，类似树状结构<br><img src="/2025/01/11/14/Pasted%20image%2020250111112002.png"></li><li>使用root：为了使Tree的Heigh不是很大</li><li>worst case:<br><img src="/2025/01/11/14/Pasted%20image%2020250111112122.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111112259.png"></li></ul><h2 id="Weighted-Quick-Union"><a href="#Weighted-Quick-Union" class="headerlink" title="Weighted  Quick Union"></a>Weighted  Quick Union</h2><ul><li>我们希望尽可能避免出现最坏情况，因此我们直观的看希望将Height小的root连接到height大的root</li><li>然而我们选择将weight小的连接到weight大的Tree<ul><li>weight Quick Union很容易实现</li><li>最后的时间复杂度是相同的，我们只关注渐近情况<br><img src="/2025/01/11/14/Pasted%20image%2020250111113749.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111113818.png"></li></ul></li><li>两种实现weighted quick union的方法：<ul><li>在父数组中使用-1以外的值来跟踪根节点的大小。</li><li>创建一个单独的size数组。<br><img src="/2025/01/11/14/Pasted%20image%2020250111113954.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111114011.png"></li></ul></li></ul><h2 id="Weighted-QuickUnion-with-Path-Compression-and-Summary"><a href="#Weighted-QuickUnion-with-Path-Compression-and-Summary" class="headerlink" title="Weighted QuickUnion with Path Compression and Summary"></a>Weighted QuickUnion with Path Compression and Summary</h2><ul><li>我们可以看出问题，QF和WQF方法在isConnected时都要经过所在值路径上的所有节点，因此我们可以进入path compression的概念，每次isConnected操作都压缩整个tree的路径，使得Tree的height越来越小。<br><img src="/2025/01/11/14/Pasted%20image%2020250111115320.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111115332.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111115354.png"><br><img src="/2025/01/11/14/Pasted%20image%2020250111115409.png"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_13</title>
    <link href="/2025/01/10/13/"/>
    <url>/2025/01/10/13/</url>
    
    <content type="html"><![CDATA[<h2 id="Characterization-1-clock-time"><a href="#Characterization-1-clock-time" class="headerlink" title="Characterization 1 clock time"></a>Characterization 1 clock time</h2><h3 id="Techniques-1-measure-execution-time-in-seconds-using-a-client-program"><a href="#Techniques-1-measure-execution-time-in-seconds-using-a-client-program" class="headerlink" title="Techniques 1: measure execution time in seconds using a client program"></a>Techniques 1: measure execution time in seconds using a client program</h3><ul><li><code>time java Dup1 1000</code> and <code>time jave Dup2 10000</code></li><li>dup1越来越长，dup2保持在一个不变的水平，引出下文</li></ul><h3 id="Techniques-2A-Count-possible-operations-for-an-array-of-size-N-10000"><a href="#Techniques-2A-Count-possible-operations-for-an-array-of-size-N-10000" class="headerlink" title="Techniques 2A: Count possible operations for an array of size N &#x3D; 10000."></a>Techniques 2A: Count possible operations for an array of size N &#x3D; 10000.</h3><ul><li>数出操作数</li><li>Good: Machine independent. </li><li>Bad: Tedious to compute. Doesn’t tell the actual time. the size is arbitrary</li></ul><h3 id="Techniques-2B-Count-possible-operations-in-terms-of-input-array-size-N"><a href="#Techniques-2B-Count-possible-operations-in-terms-of-input-array-size-N" class="headerlink" title="Techniques 2B: Count possible operations in terms of input array size N"></a>Techniques 2B: Count possible operations in terms of input array size N</h3><ul><li>Good: Machine independent. Tell how algorithm scales 算法尺度</li><li>Bad: More tedious to compute Doesn’t tell the actual time</li></ul><h2 id="WHy-Scaling-Matters-缩放"><a href="#WHy-Scaling-Matters-缩放" class="headerlink" title="WHy Scaling Matters ? 缩放"></a>WHy Scaling Matters ? 缩放</h2><h3 id="Which-is-better"><a href="#Which-is-better" class="headerlink" title="Which is better?"></a>Which is better?</h3><p><img src="/2025/01/10/13/Pasted%20image%2020250110225843.png"></p><ul><li>Fewer operations to do the same work e.g. 50,015,001 vs. 10000 operations</li><li>Better answer: Algorithm scales better in the worst case. (N2+3N+2)&#x2F;2 vs. N.</li><li>Even better answer: Parabolas (N2) grow faster than lines (N). 抛物线，几何角度</li></ul><p>伸缩良好的算法（例如，看起来像直线）比伸缩相对较差的算法（例如，看起来像抛物线）具有更好的渐近运行时行为。</p><h2 id="Wrost-Case-Oders-of-Growth"><a href="#Wrost-Case-Oders-of-Growth" class="headerlink" title="Wrost Case Oders of Growth"></a>Wrost Case Oders of Growth</h2><p><img src="/2025/01/10/13/Pasted%20image%2020250110230808.png"></p><h2 id="Simplified-analysis"><a href="#Simplified-analysis" class="headerlink" title="Simplified analysis"></a>Simplified analysis</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>不是构建整个表，我们可以：</p><ul><li>&#x3D;&#x3D;选择要计算的有代表性的操作（也就是成本模型）&#x3D;&#x3D;。</li><li>用任意一种方法计算代表性操作的计数增长顺序：<ul><li>做一个精确的计数，然后丢弃不必要的碎片。</li><li>使用直觉和检查来确定生长顺序（只有通过大量的练习才能实现）。</li></ul></li></ul><p><img src="/2025/01/10/13/Pasted%20image%2020250110231438.png"></p><p><img src="/2025/01/10/13/Pasted%20image%2020250110232217.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_12</title>
    <link href="/2025/01/09/12/"/>
    <url>/2025/01/09/12/</url>
    
    <content type="html"><![CDATA[<h2 id="Command-Line-Compilation"><a href="#Command-Line-Compilation" class="headerlink" title="Command Line Compilation"></a>Command Line Compilation</h2><h3 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h3><p><img src="/2025/01/09/12/Pasted%20image%2020250109111349.png"></p><ul><li>在IntelliJ中Compiler即javac一直隐形地运行</li><li>现将.java 通过编译器(javac) 转化为 .class ；在使用解释器 (interpreter) java最后得到结果</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">subl </span>Hello.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">javac </span>Hello.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">java </span>Hello<br></code></pre></td></tr></table></figure><h2 id="Public-static-void-main-Strinig-args"><a href="#Public-static-void-main-Strinig-args" class="headerlink" title="Public static void main(Strinig[] args)"></a>Public static void main(Strinig[] args)</h2><ul><li><code>String[] args</code>定义如何在命令行运行，即可以<code>java Hello some args</code></li><li>ArgsSum Exercise</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArgsSum</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (index &lt; args.lengeh) &#123;<br>sum = sum + Integer.parseInt(args[index])<br>index = index + <span class="hljs-number">1</span><br>&#125;<br>sout(sum)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ java ArgsSum<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<br>10<br></code></pre></td></tr></table></figure><h2 id="Git-A-command-Line-Program"><a href="#Git-A-command-Line-Program" class="headerlink" title="Git : A command Line Program"></a>Git : A command Line Program</h2><ul><li>git 是使用c写成的，所以不需要interpreter 因此不需要<code>c git status</code> 直接 <code>git status</code></li><li>every time you commit changes to a file, it stores a copy of the <strong>entire repository</strong> in a secret folder on your computer called .git</li><li>我们如何避免冗余 avoid redundancy (例子：不需要三个不同hats.java)<br><img src="/2025/01/09/12/Pasted%20image%2020250109114111.png"></li></ul><h2 id="Avoiding-Redundancy"><a href="#Avoiding-Redundancy" class="headerlink" title="Avoiding Redundancy"></a>Avoiding Redundancy</h2><h3 id="Approach-1-每次提交复制所有项目"><a href="#Approach-1-每次提交复制所有项目" class="headerlink" title="Approach 1 每次提交复制所有项目"></a>Approach 1 每次提交复制所有项目</h3><ul><li>太冗余但是容易实现，略</li></ul><h3 id="Approach-2-只储存改变的文件"><a href="#Approach-2-只储存改变的文件" class="headerlink" title="Approach 2 只储存改变的文件"></a>Approach 2 只储存改变的文件</h3><p><img src="/2025/01/09/12/Pasted%20image%2020250109114614.png"></p><ul><li>checkout 变得复杂，if we checkout a commit, we have to copy files from a variety of different folders. Inefficient</li></ul><h3 id="Approach-3-带有version-data-structure的approach-2"><a href="#Approach-3-带有version-data-structure的approach-2" class="headerlink" title="Approach 3 带有version data structure的approach 2"></a>Approach 3 带有version data structure的approach 2</h3><ul><li>不需要遍历之前的所有文件判断哪个是最新的</li><li>每一次提交都是一个”map” or “dictionary”</li><li>当两次提交提交了相同的X.java（改完又删了）我们可以通过某种方式判断，然后只提交真正修改的文件<br><img src="/2025/01/09/12/Pasted%20image%2020250109115151.png"></li></ul><h2 id="Avoiding-Redundancy-with-“Hashing”"><a href="#Avoiding-Redundancy-with-“Hashing”" class="headerlink" title="Avoiding Redundancy with “Hashing”"></a>Avoiding Redundancy with “Hashing”</h2><h3 id="Approach-4-使用时间和日期作为版本号-引出git使用方法"><a href="#Approach-4-使用时间和日期作为版本号-引出git使用方法" class="headerlink" title="Approach 4 使用时间和日期作为版本号 - 引出git使用方法"></a>Approach 4 使用时间和日期作为版本号 - 引出git使用方法</h3><ul><li>因为git大部分是在本地运行，因此我们使用时间判断谁的comimt是更早的</li><li>但是还有有缺陷，如果有两个人同时提交就无法判断，因此我们引出hash方法<br><img src="/2025/01/09/12/Pasted%20image%2020250109120525.png"></li></ul><h3 id="Approach-5-使用“Hash”作为版本号-git"><a href="#Approach-5-使用“Hash”作为版本号-git" class="headerlink" title="Approach 5 使用“Hash”作为版本号 -git"></a>Approach 5 使用“Hash”作为版本号 -git</h3><ul><li>使用”git-SHA1 hash”一个文件内容的确定性函数(deterministic function of the file’s content)，将不同内容的文件映射到独特的160bits的值</li><li>两个相同的文件有相同的git-SHA1 hash</li><li>git创建一个文件夹 .git&#x2F;objects&#x2F;66 66是hash值的前两位</li><li>在这个文件夹里git储存内容在一个文件名为ccdc…即剩余的hash</li><li>文件以一个压缩格式zlib格式来节省空间<br><img src="/2025/01/09/12/Pasted%20image%2020250109121649.png"><br><img src="/2025/01/09/12/Pasted%20image%2020250109121739.png"></li></ul><h3 id="Approach-Comparison"><a href="#Approach-Comparison" class="headerlink" title="Approach Comparison"></a>Approach Comparison</h3><p><img src="/2025/01/09/12/Pasted%20image%2020250109121854.png"></p><ul><li>git虽然有可能出现bug就是碰撞，但是概率极低不做考虑</li><li>hash方法还在一定程度上保证了安全性，因为修改内容会导致储存的hash值不同，涉及到hash链的概念</li></ul><h2 id="Serializable-and-Storing-Data-Structures"><a href="#Serializable-and-Storing-Data-Structures" class="headerlink" title="Serializable and Storing Data Structures"></a>Serializable and Storing Data Structures</h2><h3 id="Git-Commits"><a href="#Git-Commits" class="headerlink" title="Git Commits"></a>Git Commits</h3><ul><li>在上文中我们在.git&#x2F;objects 添加了66即以hash值为文件名的压缩文件</li><li>但是我们可以看到在objects 文件夹中还有10 和 9a。在9a文件中我们储存了commit.</li><li>commit 也是一个object，储存以下图中表示的内容。因此我们可以推断出commit也是一个java文件，commit id就是hash。<br><img src="/2025/01/09/12/Pasted%20image%2020250109131201.png"><br><img src="/2025/01/09/12/Pasted%20image%2020250109122621.png"></li></ul><h3 id="Storing-Commits-using-Serializable-可序列化"><a href="#Storing-Commits-using-Serializable-可序列化" class="headerlink" title="Storing Commits using Serializable 可序列化"></a>Storing Commits using Serializable 可序列化</h3><ul><li>在proj2，当user创建一个commit，我们需要以某种方式将对象存储在下面，以便稍后读取。</li><li>根据上图，9a里储存的是一个名为0fed…的文件储存日期作者等信息</li><li>commit是一个object，但是它需要以file形式储存，这是就需要用的Serializable（应该是这样吧）储存任意对象。不是很懂</li></ul><p><img src="/2025/01/09/12/Pasted%20image%2020250109133414.png"></p><ul><li>Java有一个名为Serializable的内置特性，它允许您存储任意对象。<ul><li>易于使用:只需让您的类实现Serializable（没有方法可以实现,）。</li><li>然后使用Utils类向文件中写入&#x2F;读取对象。<br><img src="/2025/01/09/12/Pasted%20image%2020250109133132.png"><br><img src="/2025/01/09/12/Pasted%20image%2020250109133203.png"><br><img src="/2025/01/09/12/Pasted%20image%2020250109133533.png"><br>生成的commit<br><img src="/2025/01/09/12/Pasted%20image%2020250109133602.png"><br>读取commit，看不太清反正是可以通过util转化成日期等等<br><img src="/2025/01/09/12/Pasted%20image%2020250109133625.png"><br><img src="/2025/01/09/12/Pasted%20image%2020250109134454.png"></li></ul></li></ul><h2 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h2><p><img src="/2025/01/09/12/Pasted%20image%2020250109135523.png"><br>-相关分支和merge</p>]]></content>
    
    
    
    <tags>
      
      <tag>UCB</tag>
      
      <tag>#DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_10</title>
    <link href="/2024/12/11/10/"/>
    <url>/2024/12/11/10/</url>
    
    <content type="html"><![CDATA[<h2 id="Dynamic-Method-Selection-Puzzle"><a href="#Dynamic-Method-Selection-Puzzle" class="headerlink" title="Dynamic Method Selection Puzzle"></a>Dynamic Method Selection Puzzle</h2><p>[[lecture10 Subtype Polymorphism vs. HoFs]]<br>[[lecture10 Subtype Polymorphism vs. HoFs#Comparables|comparator]]</p><blockquote><p>[!summary]<br>The rules:</p><ul><li>Compiler allows memory box to hold any subtype.</li><li>Compiler allows calls based on static type.</li><li>Overridden non-static methods are selected at run time based on dynamic type.</li><li>Everything else is based on static type,including overloaded methods</li></ul></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Object o3 <span class="hljs-operator">=</span> (Dog) o2<span class="hljs-comment">;</span><br>o3.bark()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!bug] </p><ul><li>Object do not have bark method </li><li>Based on rule 2</li></ul></blockquote><h2 id="Subtype-polymorphic-子类型多态性"><a href="#Subtype-polymorphic-子类型多态性" class="headerlink" title="Subtype polymorphic   子类型多态性"></a>Subtype polymorphic   子类型多态性</h2><ul><li>polymorphic: “providing a single interface to entities of different types”</li></ul><p>多个子类型使用同一个接口，在运行过程中根据不同的动态类型选择不同的方法，体现面向对象的思维。</p><h3 id="Subtype-polymorphic-vs-Explicit-Higher-Order-functions"><a href="#Subtype-polymorphic-vs-Explicit-Higher-Order-functions" class="headerlink" title="Subtype polymorphic vs. Explicit Higher Order functions"></a>Subtype polymorphic vs. Explicit Higher Order functions</h3><p>Explicit HoF Approach</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">def print_larger(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, compare, stringify):<br><span class="hljs-keyword">if</span> compare(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>):<br><span class="hljs-keyword">return</span> stringify(<span class="hljs-variable language_">x</span>)<br><span class="hljs-keyword">return</span> stringify(<span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>Subtype Polymorphism Approach</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">def print_larger(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">x</span>.largerThan(<span class="hljs-variable language_">y</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">x</span>.str()<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">y</span>.str()<br></code></pre></td></tr></table></figure><p>根据x，y不同的类型调用统一接口的largerThan的不同方法。面向对象</p><h2 id="DIY-Comparison"><a href="#DIY-Comparison" class="headerlink" title="DIY Comparison"></a>DIY Comparison</h2><p>Goal: The One True Max function</p><p><img src="/2024/12/11/10/Pasted%20image%2020241211142933.png"></p><p><img src="/2024/12/11/10/Pasted%20image%2020241211143356.png"></p><ul><li>create an interface to make all its subtype are comparable.</li><li>Make One True Max function use same name method – &gt; dynamic selection.</li><li>use Max class in terms of this interface.</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Ourcomparable</span> &#123;<br><span class="hljs-built_in">int</span> compareTo(Object obj);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">OurComparable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compareTo(Object obj)&#123;<br><span class="hljs-comment">/** Cast may cause runtime errors</span><br><span class="hljs-comment">Dog uddaDog = (Dog) obj:</span><br><span class="hljs-comment">return this.size - uddadog.size;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;...</span><br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maximizer</span> </span>&#123;<br>public static OurComparable max(OurComparable[] a) &#123;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Dog</span>[] dogs = new Dog[] &#123;<span class="hljs-built_in">d1</span>, <span class="hljs-built_in">d2</span>, <span class="hljs-built_in">d3</span>&#125;<span class="hljs-comment">;</span><br><span class="hljs-symbol">Dog</span> largest = (Dog) Maximizer.max(dogs)<br></code></pre></td></tr></table></figure><blockquote><p>[!success] </p><ul><li>No need for array maximization code in every custom type (i.e. no Dog.maxDog(Dog[]) function required).</li><li>Code that operates on multiple types (mostly) gracefully</li></ul></blockquote><h2 id="Comparables"><a href="#Comparables" class="headerlink" title="Comparables"></a>Comparables</h2><blockquote><p>[!warning] Two issues:</p><ul><li>Awkward casting to&#x2F;from Objects.</li><li>We made it up.</li><li>很多类没有实现OurComparable例如String等</li><li>没有类或函数使用OurComparable</li></ul></blockquote><p>我们要使用一个内置的comparable接口 built-in Comparable interface.</p><ul><li>use generics</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compareTo(T obj);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">Dog</span>&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compareTo(Dog uddaDog) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size - uddadog.size;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!success] Advantages:</p><ul><li>Lots of built in classes implement Comparable</li><li>Lots of libraries use the Comparable interface</li><li>Avoids need for casts.</li></ul></blockquote><h2 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h2><blockquote><p>[!hint] </p><ul><li>use different way to sort or compare somethings</li><li>In this case, we can use the size of the dogs, or we can use the name of dogs like a, b, c…</li><li>&#x3D;&#x3D;so we use comparators&#x3D;&#x3D;</li></ul></blockquote><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">def print_larger(T <span class="hljs-variable language_">x</span>, T <span class="hljs-variable language_">y</span>, comparator&lt;T&gt; c):<br><span class="hljs-keyword">if</span> c.compare(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">x</span>.str();<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">y</span>.str();<br></code></pre></td></tr></table></figure><p><img src="/2024/12/11/10/Pasted%20image%2020241211151306.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">Dog</span>&gt; &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> size;<br><br><span class="hljs-keyword">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-symbol">NameComparator</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparator</span>&lt;<span class="hljs-symbol">Dog</span>&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compare(Dog d1, Dog d2) &#123;<br><span class="hljs-keyword">return</span> d1.name.compareTo(d2.name);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>more formal way</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">Dog</span>&gt;&#123;<br><br><br><span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> <span class="hljs-symbol">NameComparator</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparator</span>&lt;<span class="hljs-symbol">Dog</span>&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compare(Dog d1, Dog d2) &#123;<br><span class="hljs-keyword">return</span> d1.name.compareTo(d2.name);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> static Comparator&lt;Dog&gt; getNameComparator() &#123;<br><span class="hljs-keyword">return</span> new Namecomparator();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">immport java.util.Comparator<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogLauncher</span> </span>&#123;<br>Comparator&lt;Dog&gt; nc = Dog.getNameComparator();<br><span class="hljs-keyword">if</span> (nc,compare(d1, d2) &gt; <span class="hljs-number">0</span>) &#123;<br>d1.bark()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>d3.bark()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/12/11/10/Pasted%20image%2020241211153720.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_11</title>
    <link href="/2024/12/11/11/"/>
    <url>/2024/12/11/11/</url>
    
    <content type="html"><![CDATA[<h2 id="Lists-and-Sets-in-java"><a href="#Lists-and-Sets-in-java" class="headerlink" title="Lists and Sets in java"></a>Lists and Sets in java</h2><h3 id="Lists-in-Real-Java-code"><a href="#Lists-in-Real-Java-code" class="headerlink" title="Lists in Real Java code"></a>Lists in Real Java code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.list;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleBuiltInListExample</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;Integer&gt; L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>L.add(<span class="hljs-number">5</span>);<br>L.add(<span class="hljs-number">10</span>);<br>L.add(<span class="hljs-number">15</span>);<br>sout(L);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Set-in-Java-–-ArraySet"><a href="#Set-in-Java-–-ArraySet" class="headerlink" title="Set in Java – ArraySet"></a>Set in Java – ArraySet</h3><blockquote><p>[!todo] Goal1: Create a class ArraySet with following methods</p><ul><li>add(value)</li><li>contain(value)</li><li>size()</li><li>ignore Resizing</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span>&lt;T&gt; &#123;<br><span class="hljs-keyword">private</span> T[] items;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySet</span><span class="hljs-params">()</span> &#123;<br>items = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T x)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (items[i].equals(x))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br><span class="hljs-keyword">if</span>(!contains(x)) &#123;<br>items[size] = x;<br>size += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArraySet&lt;String&gt; S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;();<br>S.add(<span class="hljs-string">&quot;horse&quot;</span>);<br>S.add(<span class="hljs-string">&quot;fish&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><blockquote><p>[!error] NullPointerException<br><code>s.add(null)</code></p><p><code>null.equals(null)</code></p></blockquote><p><img src="/2024/12/11/11/Pasted%20image%2020241211164918.png"></p><h3 id="Explicit-Exceptions"><a href="#Explicit-Exceptions" class="headerlink" title="Explicit Exceptions"></a>Explicit Exceptions</h3><ul><li>provide more information to users</li><li>provide more information to code that “catches” the exception</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot add null&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Other fixes:<br>- ignore nulls<br>- fix contains so that doesn’t crash if <code>items[i]</code> is <code>null</code></p><p><img src="/2024/12/11/11/Pasted%20image%2020241211165637.png"></p><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><h3 id="The-enhanced-For-Loop"><a href="#The-enhanced-For-Loop" class="headerlink" title="The enhanced For Loop"></a>The enhanced For Loop</h3><ul><li><strong>Java allows us to iterate through Lists and Sets using a convenient shorthand syntax sometimes called the “foreach” or “enhanced for” loop.</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; javaset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>javaset.add(<span class="hljs-number">5</span>);<br>javaset.add(<span class="hljs-number">23</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : javaset) &#123;<br>sout(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Ugly-iteration-how-iteration-really-works"><a href="#Ugly-iteration-how-iteration-really-works" class="headerlink" title="Ugly iteration. - how iteration really works"></a>Ugly iteration. - how iteration really works</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Set.java<br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Integer</span>&gt; javaset = <span class="hljs-literal">new</span> HashSet&lt;<span class="hljs-built_in">Integer</span>&gt;();<br><span class="hljs-params">...</span><br>java.util.Iterator&lt;<span class="hljs-built_in">Integer</span>&gt; seer = javaset.iterator();<br><br><span class="hljs-keyword">while</span> (seer.hasNext()) &#123;<br>sout(seer.next());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/12/11/11/Pasted%20image%2020241211174806.png"></p><blockquote><p>[!important] </p><ol><li>Set实现接口，需要有iterator方法.    — Arrayset继承set 有 iterator</li><li>Iterator接口需要有next和hasNext方法</li></ol></blockquote><h3 id="ArraySets-实现"><a href="#ArraySets-实现" class="headerlink" title="ArraySets 实现"></a>ArraySets 实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br><span class="hljs-function">boolean <span class="hljs-title">hasNext</span>()</span>;<br><span class="hljs-function">T <span class="hljs-title">next</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ArraySet</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>...<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ArraySetIterator</span> <span class="hljs-title">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> wizPos;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArraySetIterator</span>()</span>&#123; wizPos = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">hasNext</span>()</span> &#123; <span class="hljs-keyword">return</span> wizPos &lt; size; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span>()</span> &#123;<br>T returnItem = items[wizPos];<br>wizPos += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> returnItem;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span>()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArraySetIterator();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br>main&#123;<br>ArraySet&lt;<span class="hljs-built_in">Integer</span>&gt; aset = <span class="hljs-literal">new</span> ArraySet&lt;<span class="hljs-built_in">Integer</span>&gt;();<br><span class="hljs-params">...</span><br>Iterator&lt;<span class="hljs-built_in">Integer</span>&gt; aseer = aset.iterator();<br><br><span class="hljs-keyword">while</span> (aseer.hasNext()) &#123;<br>sout(aseer.next());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!question] </p><ul><li><p>Our code now supports “ugly” iteration, but enhanced for loop still doesn’t work.</p></li><li><p>Java isn’t smart enough to realize that our ArraySet has an iterator() method.</p></li></ul></blockquote><p><img src="/2024/12/11/11/Pasted%20image%2020241211180757.png"></p><p><img src="/2024/12/11/11/Pasted%20image%2020241211180821.png"></p><p><img src="/2024/12/11/11/Pasted%20image%2020241211180839.png"></p><blockquote><p>[!summary] iteration<br>To support the enhanced for loop:</p><ul><li>目标类需要实现iterable T 接口</li><li>目标类中需要实现iterator方法并返回Iterator T（iterable接口需求）</li><li>iterator T 私有类需要实现hasNext和next</li></ul></blockquote><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><ul><li><code>System.out.printIn(Object x)</code> calls <code>x.toString</code></li><li>The <a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/lang/Object.java#L245">implementation of toString() in Object</a> is the the name of the class, then an @ sign, then the memory location of the object.</li></ul><h3 id="One-Approach"><a href="#One-Approach" class="headerlink" title="One Approach"></a>One Approach</h3><blockquote><p>[!warning]<br>This code is slow. Intuition: Adding even a single character to a string creates an entirely new string. </p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> to <span class="hljs-title">String</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">String</span> returnString = <span class="hljs-string">&quot;&#123;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i += <span class="hljs-number">1</span>) &#123;<br>returnString += key[i];<br>returnString += <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>returnString += <span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-keyword">return</span> returnString;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!success] faster Approach<br>Append operation for a StringBuilder is fast</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override<br><span class="hljs-keyword">public</span> String to String()&#123;<br>StringBuilder returnSB = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;&#123;&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">size</span>; i += <span class="hljs-number">1</span>) &#123;<br>returnSB.<span class="hljs-keyword">append</span>(key[i]);<br>returnSB.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>&#125;<br>returnSB.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;&#125;&quot;</span>);<br><span class="hljs-keyword">return</span> returnSB.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Equals-vs"><a href="#Equals-vs" class="headerlink" title="Equals vs. &#x3D;&#x3D;"></a>Equals vs. &#x3D;&#x3D;</h2><ul><li>&#x3D;&#x3D; compares the bits. For references, &#x3D;&#x3D; means “referencing the same object.”</li><li>The default implementation of equals just uses &#x3D;&#x3D;</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> boolean equals(Object other) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == other) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br><span class="hljs-keyword">if</span> (other instanceof ArraySet otherSet) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size != otherSet.size) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br><span class="hljs-keyword">for</span> (T x : <span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">if</span> (!otherSet.contains(x)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>other instanceof ArraySet otherSet</code></p><ul><li>判断<code>other</code>的动态类型是不是<code>ArraySet</code></li><li>将<code>other</code>转化成静态类型是<code>ArraySet</code>的<code>otherSet</code></li><li><code>other</code> 是 <code>null</code> 也可以正常运作</li></ul><h3 id="Old-version"><a href="#Old-version" class="headerlink" title="Old version"></a>Old version</h3><p><img src="/2024/12/11/11/Pasted%20image%2020241212121815.png"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="/2024/12/11/11/Pasted%20image%2020241212122043.png"></p><h2 id="Even-Better-toString-and-ArraySet-of"><a href="#Even-Better-toString-and-ArraySet-of" class="headerlink" title="Even Better toString and ArraySet.of"></a>Even Better toString and ArraySet.of</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">tostring</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; listOfItems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (T x : <span class="hljs-variable language_">this</span>) &#123;<br>listOfItems.<span class="hljs-title function_">add</span>(x.<span class="hljs-title function_">toSting</span>());<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>, listOfItems);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;Glerp&gt; <span class="hljs-function">ArraySet&lt;Glerp&gt; <span class="hljs-title">of</span>(<span class="hljs-params">Glerp... stuff</span>)</span> &#123;<br>ArraySet&lt;Glerp&gt; returnSet = <span class="hljs-keyword">new</span> ArraySet&lt;Glerp&gt;();<br><span class="hljs-keyword">for</span> (Glerp x : stuff) &#123;<br>returnSet.<span class="hljs-keyword">add</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> returnSet;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ArraySet&lt;<span class="hljs-type">String</span>&gt; asetofString = ArraySet.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;I&#x27;m&quot;</span>, <span class="hljs-string">&quot;here&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_9</title>
    <link href="/2024/12/10/9/"/>
    <url>/2024/12/10/9/</url>
    
    <content type="html"><![CDATA[<h2 id="Implementation-Inheritance-Extends"><a href="#Implementation-Inheritance-Extends" class="headerlink" title="Implementation Inheritance: Extends"></a>Implementation Inheritance: Extends</h2><p>当一个类是一个接口的下位次，我们使用implement来实现继承<br>当他是一个类的下位次，我们使用extend完成继承</p><p><img src="/2024/12/10/9/Pasted%20image%2020241210172508.png"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotatingSLList&lt;Blorp&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SLList&lt;Blorp&gt;</span> </span>&#123;<br>public void rotateRight() &#123;<br><span class="hljs-type">Blorp</span> oldBack = removeLast();<br>addFirst(oldBack);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>inherits all members of SLList:</p><ul><li>All instance and static variables</li><li>All methods</li><li>All nested classes<br>&#x3D;&#x3D;Constructors&#x3D;&#x3D; are not inherited</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VengefulSLList</span>&lt;<span class="hljs-title">Item</span>&gt; <span class="hljs-title">extends</span> <span class="hljs-title">SLList</span>&lt;<span class="hljs-title">Item</span>&gt; &#123;<br><span class="hljs-keyword">private</span> SLList&lt;Item&gt; deletedItems;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VengefulSLList</span>()</span> &#123;<br>delectedItems = <span class="hljs-keyword">new</span> SLList&lt;Item&gt;();<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">removeLast</span>()</span> &#123;<br>Item oldBlack = super.removeLast(); <br><span class="hljs-meta"># call Superclass`s version of removeLast()</span><br><br>deletedItems.addLast(oldBack);<br><span class="hljs-keyword">return</span> oldBack;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLostItems</span>()</span> &#123;<br>deletedItems.print();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Super.method</strong><br>calls superclass versions of method<br>Java &#x3D;&#x3D;not allows super.super&#x3D;&#x3D;</p><h2 id="Constructor-Behaviors"><a href="#Constructor-Behaviors" class="headerlink" title="Constructor Behaviors"></a>Constructor Behaviors</h2><p><em>ALL Constructors must start with a call to one of the super class’s Constructors</em></p><p><em>ONE OF ?</em> :<br><code>super(x)</code>  <code>super()</code><br>use a super Constructor with parameters</p><ul><li>implicit call - super() –<strong>If you don’t explicitly call the constructor, Java will automatically do it for you.</strong></li></ul><p>&#x3D;&#x3D;every type in java is a descendant of the Object class&#x3D;&#x3D; implicitly<br>&#x3D;&#x3D;Is a NOT Has a&#x3D;&#x3D;</p><h2 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a>Encapsulation 封装</h2><h3 id="Complexity-The-Enemy-How-to-mange-it"><a href="#Complexity-The-Enemy-How-to-mange-it" class="headerlink" title="Complexity The Enemy : How to mange it"></a>Complexity The Enemy : How to mange it</h3><ul><li>Hierarchical abstraction.<ul><li>Create &#x3D;&#x3D;layers of abstraction&#x3D;&#x3D;, with clear abstraction barriers!</li></ul></li><li>“Design for change” (D. Parnas)<ul><li>Organize program around objects.</li><li>Let objects decide how things are done.</li><li>&#x3D;&#x3D;Hide information&#x3D;&#x3D; others don’t need.</li></ul></li></ul><p><strong>A module is said to be encapsulated if its implementation is completely hidden, and it can be accessed only through a documented interface.</strong></p><h3 id="Implementation-Inheritance-Breaks-Encapsulation"><a href="#Implementation-Inheritance-Breaks-Encapsulation" class="headerlink" title="Implementation Inheritance Breaks Encapsulation"></a>Implementation Inheritance Breaks Encapsulation</h3><p><img src="/2024/12/10/9/Pasted%20image%2020241210175319.png"></p><h2 id="Dynamic-Method-Selection-And-Type-Checking"><a href="#Dynamic-Method-Selection-And-Type-Checking" class="headerlink" title="Dynamic Method Selection And Type Checking"></a>Dynamic Method Selection And Type Checking</h2><p>[<a href="https://youtu.be/xGC4bVnTXcA?si=--fOJLFfDFO8lOVs%5D">https://youtu.be/xGC4bVnTXcA?si=--fOJLFfDFO8lOVs]</a></p><p>动态方法选择发生在动态方法集中，只在重写override情况发生<br>If overriden, decide which method to call based on run-time type</p><p>类型检查发生在编译部分，编译器检查对象的静态类型<br><img src="/2024/12/10/9/Pasted%20image%2020241210180006.png"></p><blockquote><p>[!note]<br>Expressions have compile-time types:</p><ul><li>An expression using new keyword</li><li>Methods have compile-time type</li></ul></blockquote><p><img src="/2024/12/10/9/Pasted%20image%2020241210181248.png"><br><img src="/2024/12/10/9/Pasted%20image%2020241210181300.png"></p><h2 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Poodle largerPoodle = (<span class="hljs-name">Poodle</span>) maxDog(<span class="hljs-name">frank</span>, frankSr)<br></code></pre></td></tr></table></figure><blockquote><p>[!danger]<br>get a ClassCastException at runtime.</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Poodle frank</span>  = new Poodle(<span class="hljs-string">&quot;Frank&quot;</span>, 5);<br><span class="hljs-attribute">Malamute frankSr</span> = new Malamute(<span class="hljs-string">&quot;Frank Sr.&quot;</span>, 100);<br><span class="hljs-attribute">Poodle largerPoodle</span> = (Poodle) maxDog(frank, frankSr);<br></code></pre></td></tr></table></figure><h2 id="Higher-Order-function"><a href="#Higher-Order-function" class="headerlink" title="Higher Order function"></a>Higher Order function</h2><p><img src="/2024/12/10/9/Pasted%20image%2020241210181902.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IntUnaryFunction</span> &#123;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">apply</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TenX implements IntUnaryFuncton</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">apply</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">10</span> * x;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HoFDemo</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">do_twice</span>(<span class="hljs-params">IntUnaryFunction f, <span class="hljs-built_in">int</span> x</span>)</span> &#123;<br><span class="hljs-keyword">return</span> f.apply(f.apply(x))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>sout(do_twicw(<span class="hljs-keyword">new</span> TenX(), <span class="hljs-number">2</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_8</title>
    <link href="/2024/12/10/8/"/>
    <url>/2024/12/10/8/</url>
    
    <content type="html"><![CDATA[<p><strong>方法重载</strong><br>在 Java 中，类中的方法可以具有相同的名称，但参数不同。例如，一个<code>Math</code>类可以有一个<code>add(int a, int b)</code> 方法和一个<code>add(float a, float b)</code>方法。Java 编译器非常聪明，可以根据您传入的参数选择正确的方法。具有相同名称但不同参数的方法被称为重载。</p><p><strong>使代码通用化</strong><br>考虑一种<code>largestNumber</code>仅将 AList 作为参数的方法。缺点是，<code>largestNumber</code>无论我们采用<code>AList</code>还是 ，的逻辑都是相同的<code>SLList</code>。我们只是对不同类型的列表进行操作。如果我们使用之前的方法覆盖想法，我们就会得到一个非常长的 Java 文件，其中包含许多类似的方法。此代码很难维护；如果我们修复了一个方法中的错误，我们必须手动将此修复复制到所有其他方法。</p><p>解决上述问题的方法是定义一个新的引用类型，它既表示<code>AList</code>又表示<code>SLList</code>。我们将其称为<code>List</code>。接下来，我们指定一个“is-a”关系： An <code>AList</code>is a <code>List</code>。我们对 执行相同的操作 <code>SLList</code>。让我们将其形式化为代码。</p><p><strong>接口</strong>我们将使用关键字<code>interface</code>而不是<code>class</code>来创建我们的<code>List</code>。更明确地说，我们这样写：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">List</span>&lt;<span class="hljs-symbol">Item</span>&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>关键思想是接口指定它<code>List</code>可以做什么，而不是如何做。由于所有列表都有一个<code>get</code>方法，我们将以下方法签名添加到接口类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br></code></pre></td></tr></table></figure><p>注意，我们没有定义这个方法。我们只是声明，只要我们使用<code>List</code>接口，这个方法就应该存在。</p><p>现在，我们要指定 an<code>AList</code>是 a <code>List</code>。我们将类声明更改为<code>AList</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">public AList<span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span> implements List<span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span> </span><span class="hljs-template-variable">&#123; ... &#125;</span><br></code></pre></td></tr></table></figure><p>我们可以对 执行相同的操作<code>SLList</code>。现在，回到我们的<code>largestNumber</code>方法，我们不必为每种类型的列表创建一个方法，而是只需创建一个接受 的方法<code>List</code>。只要我们的实际对象实现了<code>List</code> 接口，那么此方法就可以正常工作！</p><p><strong>覆盖</strong></p><p><code>AList</code>对于我们在 中定义的每个方法<code>List</code>，我们将在方法签名上方添加一个 @Override。例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Item <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>从技术角度来说，这并非必要，但是一种良好的风格，因此我们将要求这样做。此外，它还允许我们检查拼写错误。如果我们输入了错误的方法名称，并且有 @Override 标记，编译器将阻止我们的编译。</p><p><strong>接口继承</strong></p><p>正式来说，我们说子类从超类继承。接口包含所有方法签名，每个子类都必须实现每个签名；将其视为合同。此外，关系可以跨越多代。例如，C 可以从 B 继承，而 B 又可以从 A 继承。</p><p><strong>默认方法</strong></p><p>接口可以有默认方法。我们通过以下方式定义它：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> void <span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; ... &#125;</span><br></code></pre></td></tr></table></figure><p>我们实际上可以在接口内部实现这些方法。请注意，没有实例变量可用，但我们可以自由使用接口中定义的方法，而不必担心实现。默认方法应该适用于实现接口的任何类型的对象！子类不必在任何地方重新实现默认方法；它们可以简单地免费调用它。但是，我们仍然可以覆盖默认方法，并在子类中重新定义该方法。</p><p><strong>静态类型与动态类型</strong>Java 中的每个变量都有静态类型。这是在声明变量时指定的类型，并在编译时进行检查。每个变量也有一个动态类型；此类型是在实例化变量时指定的，并在运行时进行检查。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Thing a<span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> new Fox()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这里，<code>Thing</code>是静态类型，<code>Fox</code>是动态类型。这没问题，因为所有狐狸都是事物。我们也可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal b <span class="hljs-operator">=</span> (Animal) a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这没问题，因为所有的狐狸也是动物。我们可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Fox c <span class="hljs-operator">=</span> (Fox) b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这没问题，因为<code>b</code>指向 a <code>Fox</code>。最后，我们可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> new Squid()<br></code></pre></td></tr></table></figure><p>这很好，因为的静态类型<code>a</code>是<code>Thing</code>，并且<code>Squid</code>是一个事物。</p><p><strong>动态方法选择</strong>规则是，如果我们有一个静态类型<code>X</code>和一个动态类型<code>Y</code>，那么如果<code>Y</code>重写了来自的方法<code>X</code>，那么在运行时，我们将使用来自的方法<code>Y</code>。学生经常混淆重载和重写。</p><p><strong>重载和动态方法选择</strong>对于重载方法，动态方法选择不起作用。请考虑以下代码，其中 <code>Fox extends Animal</code>。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> Fox f = <span class="hljs-keyword">new</span> Fox();<br><span class="hljs-symbol">2 </span> Animal a = f;<br><span class="hljs-symbol">3 </span> define(f);<br><span class="hljs-symbol">4 </span> define(a);<br></code></pre></td></tr></table></figure><p>假设我们在同一个类中有以下重载方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">define</span>(<span class="hljs-params"><span class="hljs-title class_">Fox</span> f</span>) &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">define</span>(<span class="hljs-params"><span class="hljs-title class_">Animal</span> a</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>第 3 行将执行<code>define(Fox f)</code>，而第 4 行将执行<code>define(Animal a)</code>。动态方法选择仅在我们重写方法时才适用。这里没有重写，因此动态方法选择不适用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_7</title>
    <link href="/2024/10/22/7/"/>
    <url>/2024/10/22/7/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>列表与数组 列表与数组</strong><br><code>DLList</code>有一个缺点。获取第 i 个项目的速度很慢；我们必须从列表的开头或结尾开始扫描列表中的每个项目，直到到达第 i 个项目。但是，对于名为 <code>A</code>的数组，我们可以使用括号表示法 快速访问第 i 个项目<code>A[i]</code>。因此，我们的目标是用数组实现列表。</p><p><strong>AList</strong><br>将<code>AList</code>具有与我们的<code>DLList</code> 相同的 API ，这意味着它将具有与<code>DLList</code>（<code>addLast()</code>、<code>getLast()</code>、<code>removeLast()</code>和<code>get(int i)</code>）相同的方法。<code>AList</code>还将有一个<code>size</code>跟踪其大小的变量。</p><p><strong>AList 不变量 Invariant</strong><br>对于我们来说，有几个不变量<code>AList</code>。</p><ul><li><code>addLast</code>：我们要添加的下一个项目将进入位置<code>size</code>。</li><li><code>getLast</code>：我们要退回的商品已到位<code>size - 1</code>。</li><li><code>size</code>：列表中的项目数应为<code>size</code>。</li></ul><p><strong>实现 AList</strong><br>每个都有<code>AList</code>一个<code>int[]</code>名为<code>items</code>。</p><ul><li>因为<code>addLast</code>，我们将物品放入<code>items[size]</code>。</li><li>因为<code>getLast</code>，我们只是返回<code>items[size - 1]</code>。</li><li>对于<code>removeLast</code>，我们只需减少<code>size</code>（我们不需要更改<code>items</code>）。因此，如果<code>addLast</code>接下来调用 ，它只会覆盖旧值，因为大小已减少。<strong>但是，在删除对象时将其清零是一种很好的做法，因为这将节省内存。</strong> 请注意这些方法与不变量的关系有多密切。</li></ul><p><strong>抽象</strong><br>本课程的一个关键思想是实现细节可以对用户隐藏。例如，用户可能想要使用列表，但作为实现者，我们可以为他们提供任何列表实现，只要它符合他们的规范。用户不应该知道我们列表的内部工作原理。</p><p><strong>数组调整大小</strong><br>当数组太满时，我们可以调整数组大小。但是，我们已经知道数组大小不能改变。解决方案是创建一个更大的新数组，然后将旧数组值复制到新数组。现在，我们拥有了所有旧值，但我们有更多的空间来添加项目。</p><p><strong>调整大小速度 Resizing Speed</strong><br>在讲座视频中，我们每次达到数组大小限制时都会将数组大小调整一倍。结果发现这非常慢，因为将数组复制到新数组意味着我们必须对每个项目执行复制操作。最糟糕的是，由于我们只调整了一个额外的框，如果我们选择添加另一个项目，每次向数组中添加时都必须再次执行此操作。</p><p><strong>提高调整大小的性能</strong><br>我们可以创建一个包含项目的新数组，而不是添加额外的框<code>size * FACTOR</code>，其中<code>FACTOR</code>可以是任何数字，例如 2。我们将在课程的后面讨论为什么这样做速度很快。</p><p><strong>缩小数组大小</strong><br>如果我们有一个长度为 100 万的数组，但删除了数组中的 990,000 个元素，会发生什么情况？ 好吧，同样，我们可以通过创建一个大小减半的数组来缩小数组大小，例如，如果我们达到 250,000 个元素。 同样，我们将在课程的后面更严格地讨论这个问题。</p><p><strong>补充：分解代码</strong><br>有时，我们会编写执行多项操作的大型方法。更好的方法是将大型方法分解为许多较小的方法。这样做的一个优点是我们可以分段测试代码。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/** Resizes the underlying array to the target capacity. */</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>       Item[] a = (Item[]) <span class="hljs-keyword">new</span> Object[capacity];<br>       System.<span class="hljs-built_in">arraycopy</span>(items, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>       items = a;<br>   &#125;<br><br>   <span class="hljs-comment">/** Inserts X into the back of the list. */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(Item x)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (size == items.length) &#123;<br>           <span class="hljs-built_in">resize</span>(size + <span class="hljs-number">1</span>);<br>       &#125;<br><br>       items[size] = x;<br>       size = size + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>通用 AList</strong><br>上次，我们讨论了如何创建通用的<code>DLList</code>。我们可以对 做类似的事情<code>AList</code>。但我们发现在创建数组时出错了。我们的问题是 Java 中不允许使用通用数组。相反，我们将更改以下行：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">items</span> <span class="hljs-operator">=</span> new Item[<span class="hljs-number">100</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>到：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">items</span> <span class="hljs-operator">=</span> (Item[]) new Object[<span class="hljs-number">100</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这叫演员阵容cast，我们将来会了解它。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/** Array based list.</span><br><span class="hljs-comment"> *  @author Josh Hug</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//         0 1  2 3 4 5 6 7</span><br><span class="hljs-comment">// items: [6 9 -1 2 0 0 0 0 ...]</span><br><span class="hljs-comment">// size: 5</span><br><br><span class="hljs-comment">/* Invariants:</span><br><span class="hljs-comment"> addLast: The next item we want to add, will go into position size</span><br><span class="hljs-comment"> getLast: The item we want to return is in position size - 1</span><br><span class="hljs-comment"> size: The number of items in the list should be size.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AList</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> Item[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/** Creates an empty list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AList</span><span class="hljs-params">()</span> </span>&#123;<br>        items = (Item[]) <span class="hljs-keyword">new</span> Object[<span class="hljs-number">100</span>];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Resizes the underlying array to the target capacity. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>        Item[] a = (Item[]) <span class="hljs-keyword">new</span> Object[capacity];<br>        System.<span class="hljs-built_in">arraycopy</span>(items, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        items = a;<br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts X into the back of the list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(Item x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size == items.length) &#123;<br>            <span class="hljs-built_in">resize</span>(size * <span class="hljs-number">2</span>);<br>        &#125;<br><br>        items[size] = x;<br>        size = size + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the item from the back of the list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> items[size - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/** Gets the ith item in the list (0 is the front). */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> items[i];<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the number of items in the list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/** Deletes item from back of the list and</span><br><span class="hljs-comment">      * returns deleted item. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>        Item x = <span class="hljs-built_in">getLast</span>();<br>        items[size - <span class="hljs-number">1</span>] = null;<br>        size = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_6</title>
    <link href="/2024/10/18/6/"/>
    <url>/2024/10/18/6/</url>
    
    <content type="html"><![CDATA[<p><strong>SLList 的缺点</strong><br><code>addLast()</code>是速度慢！我们无法在列表中间添加元素。此外，如果我们的列表真的很大，我们必须从列表的前面开始，一直循环到列表的后面，然后再添加元素。</p><p><strong>一个简单的解决方案</strong><br>回想一下，我们将列表的大小缓存为的实例变量<code>SLList</code>。如果我们<code>last</code>也缓存列表中的元素会怎么样？突然间，<code>addLast()</code>速度又变快了；我们立即访问最后一个元素，然后将元素添加到其中。但<code>removeLast()</code>速度仍然很慢。在中 <code>removeLast()</code>，我们必须知道倒数第二个元素是什么，这样我们才能将缓存的<code>last</code>变量指向它。然后我们可以缓存一个<code>second-to-last</code> 变量，但现在如果我想删除倒数第二个元素，我需要知道倒数第三个元素在哪里。如何解决这个问题？</p><p><strong>DLList</strong><br>解决方案是给每个元素<code>IntNode</code>一个<code>prev</code>指针，指向前一个元素。这样就创建了一个双向链表，即<code>DLList</code>。经过这种修改，从列表的前面和后面添加和删除元素会变得很快（尽管从中间添加&#x2F;删除元素仍然很慢）。</p><p><strong>合并哨兵</strong><br>回想一下，我们向 添加了哨兵节点 <code>SLList</code>。对于<code>DLList</code>，我们可以有两个哨兵（一个用于前面，一个用于后面），也可以使用圆形哨兵。<code>DLList</code>使用圆形哨兵的 有一个哨兵。哨兵指向 列表的第一个元素<code>next</code>，指向 列表的最后一个元素<code>prev</code>。此外，列表的最后一个元素<code>next</code>指向哨兵，列表的第一个元素<code>prev</code>指向哨兵。对于空列表，哨兵在两个方向上都指向自身。<br><img src="/2024/10/18/6/Pasted%20image%2020241018114104.png"><br><img src="/2024/10/18/6/Pasted%20image%2020241018114115.png"></p><p><strong>通用 DLList</strong><br>我们如何修改它<code>DLList</code>，以便它可以成为我们选择的任何对象的列表？回想一下，我们的类定义如下所示：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLList</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>我们将把它改为</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;其中<code>T</code>是占位符对象类型&#x3D;&#x3D;。请注意&#x3D;&#x3D;尖括号语法&#x3D;&#x3D;。还请注意，我们不必使用<code>T</code>；任何变量名都可以。在我们的中<code>DLList</code>，我们的项目现在属于类型<code>T</code>，并且我们的方法现在将<code>T</code>实例作为参数。我们还可以将我们的<code>IntNode</code>类重命名为<code>TNode</code>以提高准确性。</p><p><strong>使用通用 DLList</strong><br>回想一下，要创建<code>DLList</code>，我们输入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">DLList list <span class="hljs-operator">=</span> new DLList(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果我们现在要创建一个<code>DLList</code>持有<code>String</code>对象，那么我们必须说：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">DLList&lt;String&gt; list <span class="hljs-operator">=</span> new DLList&lt;&gt;(<span class="hljs-string">&quot;bone&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在创建列表时，编译器会将所有的实例替换<code>T</code>为<code>String</code>！我们将在后面的课程中更详细地介绍泛型类型。</p><p><strong>数组</strong><br>回想一下，变量只是一些位的盒子。例如，为<code>int x;</code> 我们提供了一个 32 位的内存盒。数组是一个特殊的对象，&#x3D;&#x3D;它由一系列按编号顺序排列的内存盒组成&#x3D;&#x3D;！要获取数组的第 i 项<code>A</code>，请使用 <code>A[i]</code>。数组的长度不能改变，&#x3D;&#x3D;并且数组的所有元素必须是同一类型&#x3D;&#x3D;（这与 Python 列表不同）。这些盒子是从零开始索引的，这意味着对于包含 N 个元素的列表，第一个元素位于 <code>A[0]</code>，最后一个元素位于<code>A[N - 1]</code>。与常规类不同，&#x3D;&#x3D;<strong>数组没有方法！&#x3D;&#x3D;</strong><code>length</code>但是数组有一个变量。<br><img src="/2024/10/18/6/Pasted%20image%2020241018114917.png"></p><p><strong>实例化数组</strong></p><p>创建数组有三种有效符号。第一种方式指定数组的大小，并用默认值填充数组：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>第二种和第三种方法用特定值填充数组。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[] x = new int[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span>[] w = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以使用数组索引来设置数组中的值。例如，我们可以说 <code>A[3] = 4;</code>。这将访问数组的<strong>第四个</strong><code>A</code>元素并将该框中的值设置为 4。</p><p><strong>Arraycopy</strong><br>为了复制一个数组，我们可以使用 <code>System.arraycopy</code>。它需要 5 个参数；语法很难记住，所以我们建议使用网上的各种参考资料，比如 <a href="https://www.tutorialspoint.com/java/lang/system_arraycopy.htm">这个</a>。</p><p><strong>2D 数组</strong></p><p>我们可以声明多维数组。对于 2D 整数数组，我们使用以下语法：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">int[][]<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>int[4][];<br></code></pre></td></tr></table></figure><p>这将创建一个包含整数数组的数组。请注意，我们必须手动创建内部数组，如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">array</span>[<span class="hljs-number">0</span>] = new int[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>Java 还可以创建多维数组，并自动创建内部数组。为此，请使用以下语法：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">int[][]<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>int[4][4];<br></code></pre></td></tr></table></figure><p>我们也可以使用这样的符号：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">int[][]<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>int[][]&#123;&#123;1&#125;, &#123;1, 2&#125;, &#123;1, 2, 3&#125;&#125;<br></code></pre></td></tr></table></figure><p>获取具有特定值的数组。</p><p><strong>数组与类</strong></p><ul><li>两者都是用来组织一堆内存的。</li><li>两者都有固定数量的“盒子”。</li><li>&#x3D;&#x3D;数组通过方括号符号访问。类通过点符号访问。&#x3D;&#x3D;</li><li>数组中的&#x3D;&#x3D;元素必须全部为同一类型。类中的元素可以是不同类型的。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;数组索引是在运行时计算的。我们无法计算类成员变量名称&#x3D;&#x3D;。<br><img src="/2024/10/18/6/Pasted%20image%2020241018115030.png"><br><img src="/2024/10/18/6/Pasted%20image%2020241018115054.png"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_5</title>
    <link href="/2024/10/16/5/"/>
    <url>/2024/10/16/5/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>裸数据结构</strong><br><code>IntLists</code>很难使用。为了 <code>IntList</code>正确使用，程序员必须理解和利用递归，即使是简单的列表相关任务。</p><p><strong>添加衣服</strong><br>首先，我们将<code>IntList</code>类 变成<code>IntNode</code> 类。然后，我们将删除类中的所有方法<code>IntNode</code>。接下来，我们将创建一个名为 的新类<code>SLList</code>，其中包含实例变量 <code>first</code>，并且此变量应为 <code>IntNode</code>类型。 In essence, we have “wrapped” our <code>IntNode</code> with an <code>SLList</code>.</p><p><strong>使用 SLList</strong><br>作为用户，要创建列表，我调用 的构造函数 <code>SLList</code>，并传入我希望用来填充列表的数字。<code>SLList</code> 然后，构造函数将<code>IntList</code>使用该数字调用构造函数，并将其设置 <code>first</code>为指向<code>IntList</code>刚刚创建的。</p><p><strong>改进</strong><br>请注意，当创建一个具有一个值的列表时，我们写入 <code>SLList list = new SLList(1)</code>。我们不必担心像传入空值一样传入我们的<code>IntList</code>。本质上，SLList 类充当列表用户和裸体<code>IntList</code>之间的中间人。</p><p><strong>公共与私有</strong><br>我们希望用户仅通过方法修改我们的列表<code>SLList</code>，而不是直接修改<code>first</code>。我们可以通过将变量访问权限设置为来阻止其他用户这样做<code>private</code>。写入<code>private IntNode first;</code>可防止其他类中的代码访问和修改<code>first</code> （而类内的代码仍然可以这样做）。</p><p><strong>嵌套类</strong><br>我们还可以将类移入类中以创建嵌套类！您还可以将嵌套类声明为私有；这样，其他类就永远无法使用这个嵌套类。</p><p><strong>静态嵌套类</strong><br>如果<code>IntNode</code>类&#x3D;&#x3D;从不使用该类的任何变量或方法&#x3D;&#x3D;<code>SLList</code>，我们可以通过添加“static”关键字将此类变为静态的。</p><p><strong>递归辅助方法</strong><br>如果我们想在 中编写一个递归方法 <code>SLList</code>，我们该怎么做呢？毕竟，<code>SLList</code>不像 那样是一个自然递归的数据结构<code>IntNode</code>。一个常见的想法是编写一个用户可以调用的外部方法。此方法调用一个以 为参数的私有辅助方法<code>IntNode</code>。然后，此辅助方法将执行递归，并将答案返回给外部方法。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SLList &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>(IntNode p) &#123;<br>     <span class="hljs-keyword">if</span> (p.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-keyword">size</span>(p.<span class="hljs-keyword">next</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>() &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">size</span>(first);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存</strong><br>之前，我们通过返回 1 + 列表其余部分的大小来递归计算<code>IntList</code>大小。如果我们的列表变得非常大，并且我们反复调用 size 方法，这会变得非常慢。现在我们有了<code>SLList</code>，让我们简单地将列表的大小缓存为一个实例变量！请注意，如果没有<code>IntList</code> ，我们以前无法做到这一点。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Fast <span class="hljs-keyword">size</span>()<br><br><span class="hljs-keyword">private</span> IntNode sentinel;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br><br><span class="hljs-keyword">public</span> SLList(<span class="hljs-keyword">int</span> x) &#123;<br>sentinel = <span class="hljs-keyword">new</span> IntNode(<span class="hljs-number">63</span>, <span class="hljs-keyword">null</span>);<br>sentinel.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> IntNode(x, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">size</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/** Returns the size of the list. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">size</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空列表</strong><br>有了<code>SLList</code>，我们现在可以表示一个空列表。我们只需将 设置<code>first</code>为<code>null</code>并将<code>size</code>设置为<code>0</code>。但是，我们引入了一些错误；即，因为<code>first</code>现在是<code>null</code>，任何试图访问 的属性<code>first</code>（如<code>first.item</code>）的方法都将返回<code>NullPointerException</code>。当然，我们可以通过编写处理这种特殊情况的代码来修复此错误。但可能有很多特殊情况。有更好的解决方案吗？</p><p><strong>哨兵节点</strong><br>让我们使所有<code>SLList</code>对象（甚至是空列表）都相同。为此，让我们为每个 SLList 提供一个哨兵节点，该节点始终存在。实际元素位于哨兵节点之后，并且我们所有的方法都应遵循哨兵节点始终是列表中的第一个元素这一理念。</p><p><strong>不变量</strong>不变量是关于数据结构的事实，保证为真（假设您的代码中没有错误）。这为我们每次向数据结构添加功能时提供了一个方便的检查表。用户还可以保证他们信任的某些属性将得到维护。例如，具有<code>SLList</code>哨兵节点的至少具有以下不变量：</p><ul><li>哨兵引用始终指向一个哨兵节点。</li><li>最前面的项目（如果存在）始终位于 sentinel.next.item。</li><li>大小变量始终是已添加的项目总数。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-comment">/** An SLList is a list of integers, which hides the terrible truth</span><br><span class="hljs-comment">   * of the nakedness within. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SLList</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntNode</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> item;<br><span class="hljs-keyword">public</span> IntNode next;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntNode</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, IntNode n</span>)</span> &#123;<br>item = i;<br>next = n;<br>System.<span class="hljs-keyword">out</span>.println(size);<br>&#125;<br>&#125; <br><br><span class="hljs-comment">/* The first item (if it exists) is at sentinel.next. */</span><br><span class="hljs-keyword">private</span> IntNode sentinel;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> size;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lectureQuestion</span>()</span> &#123;<br>SLList L = <span class="hljs-keyword">new</span> SLList();<br>IntNode n = IntNode(<span class="hljs-number">5</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-comment">/** Creates an empty SLList. */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SLList</span>()</span> &#123;<br>sentinel = <span class="hljs-keyword">new</span> IntNode(<span class="hljs-number">63</span>, <span class="hljs-literal">null</span>);<br>size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SLList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>sentinel = <span class="hljs-keyword">new</span> IntNode(<span class="hljs-number">63</span>, <span class="hljs-literal">null</span>);<br>sentinel.next = <span class="hljs-keyword">new</span> IntNode(x, <span class="hljs-literal">null</span>);<br>size = <span class="hljs-number">1</span>;<br>&#125;<br><br> <span class="hljs-comment">/** Adds x to the front of the list. */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br> sentinel.next = <span class="hljs-keyword">new</span> IntNode(x, sentinel.next);<br> size = size + <span class="hljs-number">1</span>;<br> &#125;<br><br> <span class="hljs-comment">/** Returns the first item in the list. */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getFirst</span>()</span> &#123;<br> <span class="hljs-keyword">return</span> sentinel.next.item;<br> &#125;<br><br> <span class="hljs-comment">/** Adds x to the end of the list. */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br> size = size + <span class="hljs-number">1</span>; <br><br> IntNode p = sentinel;<br><br> <span class="hljs-comment">/* Advance p to the end of the list. */</span><br> <span class="hljs-keyword">while</span> (p.next != <span class="hljs-literal">null</span>) &#123;<br> p = p.next;<br> &#125;<br><br> p.next = <span class="hljs-keyword">new</span> IntNode(x, <span class="hljs-literal">null</span>);<br> &#125;<br> <br> <span class="hljs-comment">/** Returns the size of the list. */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">size</span>()</span> &#123;<br> <span class="hljs-keyword">return</span> size;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br> <span class="hljs-comment">/* Creates a list of one integer, namely 10 */</span><br> SLList L = <span class="hljs-keyword">new</span> SLList();<br> L.addLast(<span class="hljs-number">20</span>);<br> System.<span class="hljs-keyword">out</span>.println(L.size());<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 方法：合并相邻相同的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAdjacent</span>()</span> &#123;<br>        IntList current = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 从当前节点开始</span><br><br>        <span class="hljs-keyword">while</span> (current.rest != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果当前节点和下一个节点的值相同</span><br>            <span class="hljs-keyword">if</span> (current.first == current.rest.first) &#123;<br>                <span class="hljs-comment">// 合并相同的节点</span><br>                current.first += current.rest.first; <span class="hljs-comment">// 更新当前节点的值</span><br>                current.rest = current.rest.rest; <span class="hljs-comment">// 跳过下一个节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 移动到下一个节点</span><br>                current = current.rest;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_4</title>
    <link href="/2024/10/15/4/"/>
    <url>/2024/10/15/4/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>位</strong><br>计算机将信息存储为内存，并使用位序列（0 或 1）表示该信息。</p><p><strong>基本</strong>类型<br>基本类型是信息的表示。Java 中有 8 种基本类型：字节、短整型、整型、长整型、浮点型、双精度型、布尔型和字符型。每个基本类型由一定数量的位表示。例如，整数是 32 位基本类型，而字节是 8 位基本类型。<br><code>int</code>、<code>char</code>、<code>byte</code>、<code>short</code>、<code>long</code>、<code>float</code>、<code>double</code> 和 <code>boolean</code>。</p><p><strong>声明原始类型</strong><br>当我们将变量声明为原始类型（即 ）时，我们会留出足够的内存空间来保存位（在本例中为 32）。我们可以将其视为一个装有位的盒子。然后 Java 将变量名称映射到此盒子 Say we have a line of code <code>int y = x;</code> where <code>x</code> was defined before. Java will copy the bits inside the <code>x</code> box into the bits in the <code>y</code> box.</p><p><strong>创建对象</strong><br>当我们使用关键字创建类的实例时<code>new</code> ，Java 会为每个字段创建位框，每个框的大小由每个字段的类型定义。例如，如果 Walrus 对象有一个 <code>int</code>变量和一个<code>double</code>变量，那么 Java 将分配两个总计 96 位（32 + 64）的框来保存这两个变量。这些将设置为默认值，例如 0。然后构造函数进入并将这些位填充为适当的值。&#x3D;&#x3D;构造函数的返回值将返回框所在的内存位置&#x3D;&#x3D;，通常是 64 位的地址。然后可以将此地址存储在具有“引用类型”的变量中。</p><p><strong>引用类型</strong><br>如果变量不是原始类型，则它就是引用类型。当我们声明对象变量时，我们使用引用类型变量来存储对象在内存中的位置。请记住，这是构造函数返回的内容。&#x3D;&#x3D;引用类型始终是一个大小为 64 位的框。请注意，变量本身并不存储整个对象&#x3D;&#x3D;！</p><p><strong>平等的黄金法则</strong><br>对于原始类型，该行将<code>int y = x</code>框内的位复制<code>x</code>到<code>y</code>框中。对于引用类型，我们做同样的事情。在行中<code>Walrus newWalrus = oldWalrus;</code>，我们将框中的 64 位地址复制<code>oldWalrus</code>到<code>newWalrus</code>框中。所以我们可以把这个平等的黄金法则 (GroE) 想象成：&#x3D;&#x3D;当我们用平等分配一个值时，我们只是将位从一个内存框复制到另一个内存框&#x3D;&#x3D;！</p><p><strong>参数传递</strong><br>假设我们有一个方法<code>average(double a, double b)</code>。该方法以两个双精度数作为参数。参数传递也遵循 GRoE，即当我们调用此方法并传入两个双精度数时，我们会将这些变量中的位复制到参数变量中。</p><p><strong>数组实例化</strong><br>数组也是对象，也是使用<code>new</code>关键字实例化的。这意味着声明一个数组变量（即<code>int[] x;</code>）将创建一个 64 位引用类型变量，该变量将保存此数组的位置。当然，现在，此框包含值 null，因为我们尚未创建数组。<code>new</code>数组的关键字将创建数组并返回此数组在内存中的位置。因此，通过说<code>int[] x = new int[]&#123;0, 1, 2, 3, 4&#125;;</code>，我们将这个新创建的数组的位置设置为变量 x。请注意，数组的大小是在创建数组时指定的，并且无法更改！</p><p><strong>IntLists</strong><br>使用引用，我们递归地定义了<code>IntList</code>类。 <code>IntLists</code>是可以改变大小的整数列表（与数组不同），并存储任意数量的整数。编写<code>size</code>辅助方法可以通过递归或迭代来完成。</p><p>There are 8 primitive types in Java: </p><ul><li>byte, short, int, long, float, double, boolean, char</li></ul><p>Everything else, including arrays, is a reference type.<br><img src="/2024/10/15/4/Pasted%20image%2020241015114046.png"><br><img src="/2024/10/15/4/Pasted%20image%2020241015114322.png"><br>Can think of new as returning the address of the newly created object.</p><ul><li>Addresses in Java are 64 bits.</li><li>Example (rough picture): If object is created in memory location 2384723423, then new returns 2384723423.</li></ul><p><img src="/2024/10/15/4/Pasted%20image%2020241015114509.png"><br><img src="/2024/10/15/4/Pasted%20image%2020241015114532.png"></p><h2 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h2><p><img src="/2024/10/15/4/Pasted%20image%2020241015114131.png"><br><img src="/2024/10/15/4/Pasted%20image%2020241015114046.png"></p><h2 id="Instantiation-of-Arrays"><a href="#Instantiation-of-Arrays" class="headerlink" title="Instantiation of Arrays"></a>Instantiation of Arrays</h2><p><img src="/2024/10/15/4/Pasted%20image%2020241015114649.png"></p><p><img src="/2024/10/15/4/Pasted%20image%2020241015114713.png"></p><h2 id="InList-and-Linked-Data-Structures"><a href="#InList-and-Linked-Data-Structures" class="headerlink" title="InList and Linked Data Structures"></a>InList and Linked Data Structures</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntList</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> first;<br><span class="hljs-keyword">public</span> IntList rest;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> f, IntList r</span>)</span> &#123;<br>first = f;<br>rest = r;<br>&#125;<br><br><span class="hljs-comment">/** Return the size of the list using... recursion! */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">size</span>()</span> &#123;<br><span class="hljs-keyword">if</span> (rest == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-keyword">this</span>.rest.size();<br>&#125;<br><br><span class="hljs-comment">/** Return the size of the list using no recursion! */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">iterativeSize</span>()</span> &#123;<br>IntList p = <span class="hljs-keyword">this</span>;<br><span class="hljs-built_in">int</span> totalSize = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>totalSize += <span class="hljs-number">1</span>;<br>p = p.rest;<br>&#125;<br><span class="hljs-keyword">return</span> totalSize;<br>&#125;<br><br><span class="hljs-comment">/** Returns the ith item of this IntList. */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> first;<br>&#125;<br><span class="hljs-keyword">return</span> rest.<span class="hljs-keyword">get</span>(i - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>IntList L = <span class="hljs-keyword">new</span> IntList(<span class="hljs-number">15</span>, <span class="hljs-literal">null</span>);<br>L = <span class="hljs-keyword">new</span> IntList(<span class="hljs-number">10</span>, L);<br>L = <span class="hljs-keyword">new</span> IntList(<span class="hljs-number">5</span>, L);<br><br>System.<span class="hljs-keyword">out</span>.println(L.<span class="hljs-keyword">get</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_3</title>
    <link href="/2024/10/14/3/"/>
    <url>/2024/10/14/3/</url>
    
    <content type="html"><![CDATA[<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>我们将介绍一种新的编程方法，即&#x3D;&#x3D;测试驱动开发 (TDD)，其中程序员在编写实际函数之前为该函数编写测试&#x3D;&#x3D;。由于单元测试是在函数之前编写的，因此隔离代码中的错误变得容易得多。此外，编写单元测试要求您对正在执行的任务有相对扎实的理解。这种方法的一个缺点是它可能相当慢，并且很容易忘记测试函数之间的交互方式。</p><h3 id="ad-hoc-testing-临时测试"><a href="#ad-hoc-testing-临时测试" class="headerlink" title="ad-hoc testing 临时测试"></a>ad-hoc testing 临时测试</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TestSort &#123;<br><span class="hljs-comment">/** Test the sort method of the Sort class. */</span><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> testSort()&#123;<br>String[] input = &#123;&quot;behave&quot;, &quot;of&quot;, &quot;failing&quot;, &quot;rocking&quot;&#125;;<br>String[] expected = &#123;&quot;behave&quot;, &quot;failing&quot;, &quot;of&quot;, &quot;rocking&quot;&#125;;<br>Sort.sort(<span class="hljs-keyword">input</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">input</span>.length; i += <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">input</span>[i].equals(expected[i]))&#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Mismatch at position&quot; + i &quot;,<br>expected: &quot; + expected[i] + &quot;, but got &quot; + <span class="hljs-keyword">input</span>[i]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>  testSort();   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>for … -&gt; <code>org.junit.Assert.assertArrayEquals(expected, input)</code></p><ul><li>返回 void</li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul><li><strong>Annotate each test with <code>@org.junit.Test</code></strong></li><li>import <code>static org.junit.Assert.*</code>；-&gt; <code>assertArrayEquals(expected, input)</code></li><li>不需要main方法。<code>import org.junit.Test;</code>  <code>@org.junit.Test</code> -&gt; <code>@Test</code></li><li>编写 JUnit 测试时，最好在要测试的函数上方写上“@Test”。这样，所有测试方法都可以非静态运行。</li></ul><p><img src="/2024/10/14/3/1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><span class="hljs-comment">/** Tests the the Sort class. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSort</span> &#123;<br>    <span class="hljs-comment">/** Test the Sort.sort method. */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSort</span><span class="hljs-params">()</span> &#123;<br>        String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>        String[] expected = &#123;<span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;;<br><br>        Sort.sort(input);<br><br>        assertArrayEquals(expected, input);<br>    &#125;<br><br>    <span class="hljs-comment">/** Test the Sort.findSmallest method. */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFindSmallest</span><span class="hljs-params">()</span> &#123;<br>        String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">expected</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">actual</span> <span class="hljs-operator">=</span> Sort.findSmallest(input, <span class="hljs-number">0</span>);<br>        assertEquals(expected, actual);<br><br>        String[] input2 = &#123;<span class="hljs-string">&quot;there&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;many&quot;</span>, <span class="hljs-string">&quot;pigs&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">expected2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">actual2</span> <span class="hljs-operator">=</span> Sort.findSmallest(input2, <span class="hljs-number">2</span>);<br>        assertEquals(expected2, actual2);<br>    &#125;<br><br>    <span class="hljs-comment">/** Test the Sort.swap method. */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSwap</span><span class="hljs-params">()</span> &#123;<br>        String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        String[] expected = &#123;<span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br><br>        Sort.swap(input, a, b);<br>        assertArrayEquals(expected, input);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol><li>Write a testing method that will take in 2 arrays and see if they are equal. These arrays can have nested arrays and those nested arrays can have nested arrays and so forth.</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> static org.junit.Assert.*;<br><span class="hljs-comment">/** Test two arrays. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TestArrayEqual</span> &#123;<br>    <span class="hljs-comment">/** Test the method. */</span><br>    @Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> areArraysEqual(Object[] <span class="hljs-built_in">array</span>1, Object[] <span class="hljs-built_in">array</span>2) &#123;<br>       <span class="hljs-comment">// 检查引用是否相等 </span><br>   (<span class="hljs-built_in">array</span>1 == <span class="hljs-built_in">array</span>2) <br>   &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125; <br>   <br>   <span class="hljs-comment">// 检查空值 </span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>1 == <span class="hljs-literal">null</span> || <span class="hljs-built_in">array</span>2 == <span class="hljs-literal">null</span>) <br>   &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <br>   <br>   <span class="hljs-comment">// 检查长度 </span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>1.length != <span class="hljs-built_in">array</span>2.length) <br>   &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <br><br><span class="hljs-comment">// 检查每个元素 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>1.length; i++) &#123; <br><br><span class="hljs-comment">// 检查是否为数组 </span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>1[i] instanceof Object[] &amp;&amp; <span class="hljs-built_in">array</span>2[i] instanceof Object[]) &#123; <br><br><span class="hljs-comment">// 如果都是数组，递归比较 </span><br><span class="hljs-keyword">if</span> (!areArraysEqual((Object[]) <span class="hljs-built_in">array</span>1[i], (Object[]) <span class="hljs-built_in">array</span>2[i])) &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br><span class="hljs-comment">// 发现不相等，返回 false &#125; </span><br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>1[i] == <span class="hljs-literal">null</span> || <span class="hljs-built_in">array</span>2[i] == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 如果一个为 null，另一个不为 null </span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">array</span>1[i].equals(<span class="hljs-built_in">array</span>2[i])) &#123; <br><span class="hljs-comment">// 直接比较元素值 </span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <br>&#125; <br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 所有检查通过</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>If we have 2 objects, Object o1 and Object o2, that have identical qualities, will <code>assertEquals(o1, o2)</code> assert true or false?</li></ol><h3 id="默认的-equals-方法"><a href="#默认的-equals-方法" class="headerlink" title="默认的 equals 方法"></a>默认的 <code>equals</code> 方法</h3><ol><li><p><strong>来源</strong>：</p><ul><li>在 Java 中，所有类都直接或间接继承自 <code>Object</code> 类，而 <code>Object</code> 类提供了一个默认的 <code>equals</code> 方法。</li></ul></li><li><p><strong>行为</strong>：</p><ul><li>默认实现的 <code>equals</code> 方法比较的是两个对象的引用（即它们在内存中的地址）。</li><li>只有当两个对象的引用相同（即指向同一个对象）时，<code>equals</code> 方法才会返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_1</title>
    <link href="/2024/10/08/1/"/>
    <url>/2024/10/08/1/</url>
    
    <content type="html"><![CDATA[<h1 id="Our-Frist-Java-Programs"><a href="#Our-Frist-Java-Programs" class="headerlink" title="Our Frist Java Programs"></a>Our Frist Java Programs</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> viod <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>in java, all code must be part of a class</li><li>Classes are defined with public class CLASSNAME</li><li>use { } to delineate beginning and ending</li><li>end lines with semicolon ;</li><li>code we want to run must be inside <em><strong>public static[[lecture2#Static vs. Instance Members]] void main (String[] args)</strong></em></li></ul><p>Java - strict requirements:</p><ul><li>every java file contain a class declaration(声明，不一定是类interfaces)</li><li>ALL CODE live inside a class</li><li>run a java program, define a main method using <em><strong>public static void main (String[] args)</strong></em></li></ul><h2 id="Hello-Numbers"><a href="#Hello-Numbers" class="headerlink" title="Hello Numbers"></a>Hello Numbers</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">public class HelloNumbers &#123;<br>public static void <span class="hljs-selector-tag">main</span>(String<span class="hljs-selector-attr">[]</span> args) &#123;<br>int <span class="hljs-attribute">x</span>;<br><span class="hljs-attribute">x</span> = <span class="hljs-number">0</span>;<br>while (<span class="hljs-attribute">x</span>&lt;<span class="hljs-number">10</span>) &#123;<br>System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-attribute">x</span>);<br><span class="hljs-attribute">x</span> = x+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-attribute">x</span> = <span class="hljs-string">&quot;horse&quot;</span>;  <span class="hljs-comment">// doesn`t work</span><br>String <span class="hljs-attribute">x</span> = <span class="hljs-string">&quot;hores&quot;</span>; <span class="hljs-comment">//doesn`t work</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>java变量,参数，方法在被使用前，必须声明</li><li>java变量必须有一个特定类型</li><li>表达式也有类型 larger（5，10）+ 3 – int</li><li>java变量类型不改变</li><li><em>类型在代码运行前被检验</em>  - python在运行中检验类型</li></ul><h2 id="Larger"><a href="#Larger" class="headerlink" title="Larger"></a>Larger</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LargerDemo</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">larger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(x&gt;y)&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>Systerm.<span class="hljs-keyword">out</span>.println(larger(<span class="hljs-number">-5</span>,<span class="hljs-number">10</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数作为类的一部分在java中被声明</li><li>作为类的一部分的函数叫做“方法” method</li><li>定义函数使用“public static” …</li><li>函数的所有参数必须具有声明的类型，  </li><li>函数的返回值必须具有声明的类型。  </li><li>&#x3D;&#x3D;Java中的函数只返回一个值!&#x3D;&#x3D;</li></ul><h2 id="Reflections-on-Java"><a href="#Reflections-on-Java" class="headerlink" title="Reflections on Java"></a>Reflections on Java</h2><h3 id="Compilation-vs-Interpretation"><a href="#Compilation-vs-Interpretation" class="headerlink" title="Compilation vs Interpretation"></a>Compilation vs Interpretation</h3><p><img src="/2024/10/08/1/111.png"><br>why a class file?</p><ul><li>.class文件已进行类型检查。分布式代码更安全。  </li><li>.class文件对于机器来说更容易执行。分布式代码更快。  </li><li>小好处:保护你的知识产权。没有必要透露消息来源。</li></ul><h3 id="Reflections-on-Static-Typing"><a href="#Reflections-on-Static-Typing" class="headerlink" title="Reflections on Static Typing"></a>Reflections on Static Typing</h3><p>Good：</p><ul><li>easy to debug</li><li>type errors 几乎不出现在用户电脑上</li><li>easier to read and reason about code</li><li>run efficiently</li></ul><p>Bad:</p><ul><li>冗长</li><li>代码不通用 e.g. would need a second larger function to compare non-integers like 5.5.</li></ul><h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h2><ul><li>a model for programing<ul><li>模块化</li><li>允许数据抽象: 可以在不知道如何实现的情况下与对象进行交互</li></ul></li><li>Objects<ul><li>对象将信息和相关行为捆绑在一起  </li><li>每个对象都有自己的本地声明  </li><li>多个对象可能都是同一类型class的实例</li></ul></li><li>Classes<ul><li>类充当其所有实例的模板  </li><li>Each object is an instance of some class</li></ul></li></ul><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><ul><li>python  <code>__init__</code></li><li><pre><code class="hljs"></code></pre></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> model;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> gas;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-type">String</span> m)</span> </span>&#123;<br>       model = m;<br>       gas = <span class="hljs-number">5</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先声明</li><li>可以有额外参数m</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul><li>Calling a method on an object might change its state</li><li>The object knows how to manage its own state, based on method calls</li><li>In Java: The return value of the method must have a type<br><code>public void / int</code></li></ul><h3 id="Java-Syntax-this-Keyword"><a href="#Java-Syntax-this-Keyword" class="headerlink" title="Java Syntax: this Keyword"></a>Java Syntax: this Keyword</h3><ul><li>类似python中的self，访问对象当前实例变量或方法</li><li>不必须</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">gasLeft</span>()</span> &#123;<br>   <span class="hljs-keyword">return</span> gas;<br>   <span class="hljs-comment">//return this.gas;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>&#123;<br><span class="hljs-keyword">public</span> String model;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> gas;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params">Sting m</span>)</span>&#123;<br>model = m;<br>gas = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> viod <span class="hljs-title">drive</span>()</span>&#123;<br><span class="hljs-keyword">if</span> (gas&lt;<span class="hljs-number">5</span>)&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Cannot drive&quot;</span>)<br><span class="hljs-keyword">return</span>;<br>&#125;<br>gas -= <span class="hljs-number">5</span>;<br>System.<span class="hljs-keyword">out</span>.println(model + <span class="hljs-string">&quot;goes vroom!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">gasLeft</span>()</span>&#123;<br><span class="hljs-keyword">return</span> gas;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addGas</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> amount</span>)</span>&#123;<br>gas = gas + amount;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Creating-and-Accessing-Objects"><a href="#Creating-and-Accessing-Objects" class="headerlink" title="Creating and Accessing Objects"></a>Creating and Accessing Objects</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br><br>   <span class="hljs-title class_">Car</span> c1;<br><br>   <span class="hljs-title class_">Car</span> c2;<br><br>   c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Honda Civic&quot;</span>);<br><br>   c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Model T&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Use dot notation to access methods of an object</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br><br>   ...<br><br>   System.<span class="hljs-keyword">out</span>.println(c1.gasLeft()); <span class="hljs-comment">// 5</span><br><br>  <br><br>   c1.drive(); <span class="hljs-comment">// Honda Civic goes vroom</span><br><br>   System.<span class="hljs-keyword">out</span>.println(c1.gasLeft()); <span class="hljs-comment">// 0</span><br><br>  <br><br>   c1.addGas(<span class="hljs-number">1</span>);<br><br>   System.<span class="hljs-keyword">out</span>.println(c1.gasLeft()); <span class="hljs-comment">// 1</span><br><br>  <br><br>   c1.drive(); <span class="hljs-comment">// Cannot drive</span><br><br>  <br><br>   System.<span class="hljs-keyword">out</span>.println(c2.gasLeft()); <span class="hljs-comment">// 5</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>#UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61b_lecture_2</title>
    <link href="/2024/10/08/2/"/>
    <url>/2024/10/08/2/</url>
    
    <content type="html"><![CDATA[<p>3:50</p><h1 id="Using-and-Defining-Classes"><a href="#Using-and-Defining-Classes" class="headerlink" title="Using and Defining Classes"></a>Using and Defining Classes</h1><h2 id="defining-and-instantiation-classes"><a href="#defining-and-instantiation-classes" class="headerlink" title="defining and instantiation classes"></a>defining and instantiation classes</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span>()</span> &#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Bark!&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogLauncher</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>      <span class="hljs-title class_">Dog</span>.<span class="hljs-title function_">makeNoise</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Dog &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> weightInPounds;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> makeNoise() &#123;<br>        <span class="hljs-keyword">if</span> (weightInPounds &lt; <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;yipyipyip!&quot;);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weightInPounds &lt; <span class="hljs-number">30</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;bark. bark.&quot;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;woof!&quot;);<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogLauncher</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Dog</span> d;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        d.<span class="hljs-property">weightInPounds</span> = <span class="hljs-number">20</span>;<br>        d.<span class="hljs-title function_">makeNoise</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>When run, this program will create a <code>Dog</code> with weight 20, and that <code>Dog</code> will soon let out a nice “bark. bark.”.</p><h2 id="一些观察和术语"><a href="#一些观察和术语" class="headerlink" title="一些观察和术语"></a>一些观察和术语</h2><ul><li>java中的对象时类的实例化</li><li>dog类有自己的变量，也叫实例变量或者非静态变量 <em>instance variables</em> or <em>non-static variables</em>.</li><li>Dog类中创建的方法没有static关键字。我们称这种方法为实例方法或非静态方法。</li><li>要调用makeNoise方法，我们必须首先使用new关键字实例化Dog，然后使特定的Dog吠叫。换句话说，我们调用d.makeNoise()而不是Dog.makeNoise()。</li><li>Once an object has been instantiated, it can be <em>assigned</em> to a <em>declared</em> variable of the appropriate type, e.g. <code>d = new Dog();</code></li><li>Variables and methods of a class are also called <em>members</em> of a class.</li><li>Members of a class are accessed using <em>dot notation</em>.</li><li>非静态方法，又名实例方法 如果方法将由类的实例调用，那么它应该是非静态的。</li></ul><h3 id="Arrays-of-objects"><a href="#Arrays-of-objects" class="headerlink" title="Arrays of objects"></a>Arrays of objects</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Dog[] <span class="hljs-operator">=</span> new Dog[<span class="hljs-number">2</span>]<span class="hljs-comment">;</span><br>dogs[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> new Dog[<span class="hljs-number">8</span>]<span class="hljs-comment">;</span><br>dogs[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> new Dog[<span class="hljs-number">20</span>]<span class="hljs-comment">;</span><br>dogs[<span class="hljs-number">0</span>].makeNoise()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="Static-vs-Instance-Members"><a href="#Static-vs-Instance-Members" class="headerlink" title="Static vs. Instance Members"></a>Static vs. Instance Members</h2><ul><li>static 方法通过类名被调用 <code>Dog.makeNoise()</code></li><li>instance 实例方法被实例名调用<code>maya.makeNoise()</code></li><li>Static methods can’t access “my” instance variables, because there is no “me”.</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span>()</span> &#123;<br><br>   System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Bark!&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>This method cannot access weightInPounds!</strong>&#x3D;&#x3D;</p><h3 id="why-static-methods"><a href="#why-static-methods" class="headerlink" title="why static methods?"></a>why static methods?</h3><p>Some classes are never instantiated. For example, Math.</p><ul><li>x &#x3D; Math.round(5.6);<br>Sometimes, classes may have <em>a mix of static and non-static methods</em>, e.g.</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>  <span class="hljs-type">int</span> weight;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> </span>&#123; ... &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> binomen = <span class="hljs-string">&quot;canis&quot;</span>;<br><br>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> Dog <span class="hljs-title">maxDog</span><span class="hljs-params">(Dog d1, Dog d2)</span> </span>&#123;<br><br>     <span class="hljs-keyword">if</span> (d<span class="hljs-number">1.</span>weight &gt; d<span class="hljs-number">2.</span>weight) &#123;<br><br>        <span class="hljs-keyword">return</span> d1;<br><br>     &#125;<br><br>     <span class="hljs-keyword">return</span> d2;<br><br>  &#125;<br><br>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Dog <span class="hljs-title">maxDog</span><span class="hljs-params">(Dog d2)</span> </span>&#123;<br><br>     <span class="hljs-keyword">if</span> (weight &gt; d<span class="hljs-number">2.</span>weight) &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br><br>     &#125;<br><br>     <span class="hljs-keyword">return</span> d2;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogLauncher</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>     <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">15</span>);<br><br>     <span class="hljs-type">Dog</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">100</span>);<br><br>  <br><br>     <span class="hljs-type">Dog</span> <span class="hljs-variable">bigger</span> <span class="hljs-operator">=</span> Dog.maxDog(d, d2);<br><br>     bigger.makeNoise();<br><br>  <br><br>     bigger = d.maxDog(d2);<br><br>     bigger.makeNoise();<br><br>  <br><br>     System.out.println(Dog.binomen);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h2><ul><li>Breakpoints: Places in the code where the debugger will pause and let you inspect the program state</li><li>In IntelliJ:<ul><li>To set&#x2F;unset breakpoints, click just to the right of the line number</li><li>Breakpoints are highlighted in red</li><li>Click    to launch the debugger and run the program, pausing at breakpoints<br>…</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>DataStructure</tag>
      
      <tag>UCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
